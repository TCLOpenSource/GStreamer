From a522178a8f08a006a541a1c6ecd6afaaffab584b Mon Sep 17 00:00:00 2001
From: TCLCode <opensource@tcl.com>
Date: Thu, 6 Mar 2025 11:39:39 +0800
Subject: [PATCH] TCL modifications for gst-plugins-good

---
 .../ext/gdk_pixbuf/gstgdkpixbufdec.c          |  26 +-
 .../gst-plugins-good/ext/jpeg/gstjpegdec.c    | 251 ++++-
 .../gst-plugins-good/ext/jpeg/gstjpegdec.h    |   5 +
 .../gst-plugins-good/ext/jpeg/meson.build     |   2 +-
 .../gst-plugins-good/ext/libpng/gstpngdec.c   |   7 +-
 .../gst-plugins-good/ext/soup/gstsouploader.c |   4 +-
 .../gst/audioparsers/gstaacparse.c            | 123 ++-
 .../gst/audioparsers/gstaacparse.h            |   8 +
 .../gst/audioparsers/gstac3parse.c            | 357 ++++++-
 .../gst/audioparsers/gstac3parse.h            |  15 +
 .../gst/audioparsers/gstac4parse.c            | 397 ++++++++
 .../gst/audioparsers/gstac4parse.h            |  66 ++
 .../audioparsers/gstaudioparserselements.h    |   4 +
 .../gst/audioparsers/gstdcaparse.c            | 145 ++-
 .../gst/audioparsers/meson.build              |   1 +
 .../gst/audioparsers/plugin.c                 |   3 +
 .../gst/autodetect/gstautodetectplugin.c      |   4 +
 subprojects/gst-plugins-good/gst/avi/gstavi.c |   2 +
 .../gst-plugins-good/gst/avi/gstavidemux.c    | 298 +++++-
 .../gst-plugins-good/gst/avi/gstavidemux.h    |   9 +
 .../gst-plugins-good/gst/flv/gstflvdemux.c    |  17 +-
 .../gst-plugins-good/gst/isomp4/fourcc.h      |   5 +
 .../gst/isomp4/gstavprotocol.c                | 388 ++++++++
 .../gst/isomp4/gstavprotocol.h                |  79 ++
 .../gst/isomp4/isomp4-plugin.c                |   2 +
 .../gst-plugins-good/gst/isomp4/meson.build   |  21 +-
 .../gst-plugins-good/gst/isomp4/qtdemux.c     | 878 +++++++++++++++++-
 .../gst-plugins-good/gst/isomp4/qtdemux.h     |  99 ++
 .../gst/isomp4/qtdemux_types.c                |   3 +
 .../gst/matroska/matroska-demux.c             | 456 ++++++++-
 .../gst/matroska/matroska-demux.h             |   6 +
 .../gst/matroska/matroska-ids.h               |   9 +
 .../gst/matroska/matroska-read-common.c       |   6 +
 .../gst-plugins-good/gst/matroska/matroska.c  |   2 +
 .../gst/rtp/gstrtpjpegdepay.c                 |   2 +-
 .../gst-plugins-good/gst/rtsp/gstrtspsrc.c    |   1 +
 .../gst/wavparse/gstwavparse.c                |  61 +-
 .../gst/wavparse/gstwavparse.h                |   4 +
 subprojects/gst-plugins-good/meson.build      |  12 +-
 39 files changed, 3715 insertions(+), 63 deletions(-)
 create mode 100755 subprojects/gst-plugins-good/gst/audioparsers/gstac4parse.c
 create mode 100755 subprojects/gst-plugins-good/gst/audioparsers/gstac4parse.h
 mode change 100644 => 100755 subprojects/gst-plugins-good/gst/audioparsers/gstaudioparserselements.h
 mode change 100644 => 100755 subprojects/gst-plugins-good/gst/audioparsers/meson.build
 mode change 100644 => 100755 subprojects/gst-plugins-good/gst/audioparsers/plugin.c
 create mode 100644 subprojects/gst-plugins-good/gst/isomp4/gstavprotocol.c
 create mode 100644 subprojects/gst-plugins-good/gst/isomp4/gstavprotocol.h

diff --git a/subprojects/gst-plugins-good/ext/gdk_pixbuf/gstgdkpixbufdec.c b/subprojects/gst-plugins-good/ext/gdk_pixbuf/gstgdkpixbufdec.c
index 5482998c0d..30c67eec91 100644
--- a/subprojects/gst-plugins-good/ext/gdk_pixbuf/gstgdkpixbufdec.c
+++ b/subprojects/gst-plugins-good/ext/gdk_pixbuf/gstgdkpixbufdec.c
@@ -79,12 +79,21 @@ GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (gdkpixbufdec, "gdkpixbufdec",
     GST_RANK_SECONDARY, GST_TYPE_GDK_PIXBUF_DEC,
     gdk_pixbuf_element_init (plugin));
 
+#ifdef TCL_PATCH
+#define BI_RGB 0
+#define BI_RLE8 1
+#define BI_RLE4 2
+#define BI_BITFIELDS 3
+#endif
+
 static gboolean
 gst_gdk_pixbuf_dec_sink_setcaps (GstGdkPixbufDec * filter, GstCaps * caps)
 {
   const GValue *framerate;
   GstStructure *s;
-
+#ifdef TCL_PATCH
+  gint32 cformat = -1, height = 0;
+#endif
   s = gst_caps_get_structure (caps, 0);
 
   if ((framerate = gst_structure_get_value (s, "framerate")) != NULL) {
@@ -97,6 +106,14 @@ gst_gdk_pixbuf_dec_sink_setcaps (GstGdkPixbufDec * filter, GstCaps * caps)
     filter->in_fps_d = 1;
     GST_DEBUG_OBJECT (filter, "no framerate, assuming single image");
   }
+#ifdef TCL_PATCH
+    if(gst_structure_get_int(s,"cformat", &cformat) && gst_structure_get_int(s,"height", &height)){
+      if((cformat == BI_RLE8 || cformat == BI_RLE4) && height < 0){
+          GstTagList *image_r_flip_tag =  gst_tag_list_new (GST_TAG_IMAGE_ORIENTATION_FLIP, "rotate-180-horiz", NULL);
+          gst_pad_push_event (filter->srcpad, gst_event_new_tag (image_r_flip_tag));
+      }
+    }
+#endif
 
   return TRUE;
 }
@@ -354,6 +371,13 @@ gst_gdk_pixbuf_dec_flush (GstGdkPixbufDec * filter)
   out_pix = GST_VIDEO_FRAME_PLANE_DATA (&frame, 0);
   out_rowstride = GST_VIDEO_FRAME_PLANE_STRIDE (&frame, 0);
 
+#ifdef TCL_PATCH
+  if (in_pix == NULL || out_pix == NULL) {
+    gst_video_frame_unmap (&frame);
+    goto no_pixbuf;
+  }
+#endif
+
   for (y = 0; y < height; y++) {
     memcpy (out_pix, in_pix, width * GST_VIDEO_FRAME_COMP_PSTRIDE (&frame, 0));
     in_pix += in_rowstride;
diff --git a/subprojects/gst-plugins-good/ext/jpeg/gstjpegdec.c b/subprojects/gst-plugins-good/ext/jpeg/gstjpegdec.c
index 15d1ab5471..9af87e65c3 100644
--- a/subprojects/gst-plugins-good/ext/jpeg/gstjpegdec.c
+++ b/subprojects/gst-plugins-good/ext/jpeg/gstjpegdec.c
@@ -48,8 +48,9 @@
 #include <jerror.h>
 
 /* Disable libjpeg-turbo support for now, due to unresolved cornercases */
+#ifndef TCL_PATCH
 #undef JCS_EXTENSIONS
-
+#endif
 #define MIN_WIDTH  1
 #define MAX_WIDTH  65535
 #define MIN_HEIGHT 1
@@ -64,6 +65,10 @@
 enum
 {
   PROP_0,
+#ifdef TCL_PATCH
+  PROP_IMAGE_PLAY,
+  PROP_CANCEL_PARSE,
+#endif
   PROP_IDCT_METHOD,
   PROP_MAX_ERRORS
 };
@@ -168,6 +173,17 @@ gst_jpeg_dec_class_init (GstJpegDecClass * klass)
           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS | G_PARAM_DEPRECATED));
 #endif
 
+#ifdef TCL_PATCH
+  g_object_class_install_property (gobject_class, PROP_IMAGE_PLAY,
+         g_param_spec_boolean ("imageplayer", "Image Player",
+             "when TURE,image player pipeline",FALSE,
+             G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+  g_object_class_install_property (gobject_class, PROP_CANCEL_PARSE,
+         g_param_spec_boolean ("cancel-parse", "CANCEL PARSE",
+             "when imageplayer release to cancel parse",FALSE,
+             G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+#endif
+
   gst_element_class_add_static_pad_template (element_class,
       &gst_jpeg_dec_src_pad_template);
   gst_element_class_add_static_pad_template (element_class,
@@ -250,9 +266,19 @@ METHODDEF (void)
     gst_jpeg_dec_my_error_exit (j_common_ptr cinfo)
 {
   struct GstJpegDecErrorMgr *err_mgr = (struct GstJpegDecErrorMgr *) cinfo->err;
-
+#ifdef TCL_PATCH
+  if (err_mgr->pub.msg_code == JERR_UNKNOWN_MARKER) {
+    gchar err_msg[JMSG_LENGTH_MAX];
+    err_mgr->pub.format_message (cinfo, err_msg);
+    GST_ERROR("unkown marker type %s", err_msg);
+  } else {
+    (*cinfo->err->output_message) (cinfo);
+    longjmp (err_mgr->setjmp_buffer, 1);
+  }
+#else
   (*cinfo->err->output_message) (cinfo);
   longjmp (err_mgr->setjmp_buffer, 1);
+#endif
 }
 
 static void
@@ -282,6 +308,9 @@ gst_jpeg_dec_init (GstJpegDec * dec)
   dec->idct_method = JPEG_DEFAULT_IDCT_METHOD;
   dec->max_errors = JPEG_DEFAULT_MAX_ERRORS;
 
+  dec->imageplayer = FALSE;
+  dec->cancel_parse = FALSE;
+
   gst_video_decoder_set_use_default_pad_acceptcaps (GST_VIDEO_DECODER_CAST
       (dec), TRUE);
   GST_PAD_SET_ACCEPT_TEMPLATE (GST_VIDEO_DECODER_SINK_PAD (dec));
@@ -295,6 +324,86 @@ gst_jpeg_dec_parse_tag_has_entropy_segment (guint8 tag)
   return FALSE;
 }
 
+#ifdef TCL_PATCH
+//at least 4
+static guint32 swapEndianness (guint32 value, gboolean littleEndian, gint byte) {
+    if (byte == 4 && littleEndian) {
+        return ((value >> 24) & 0xff) | ((value >> 8) & 0xff00)
+            | ((value << 8) & 0xff0000) | ((value << 24) & 0xff000000);
+    }
+
+    if (byte == 2 && littleEndian) {
+        return ((value >> 24) & 0xff) | ((value >> 8) & 0xff00);
+    }
+
+    if (byte == 2) {
+        return ((value >> 16) & 0xffff);
+    }
+
+    return value;
+}
+
+#define EXIF_TAG_ORIENTATION 0x0112
+#define APP1                 0xe1
+#define EXIF                 0x45786966
+#define TIIF_II              0x49492a00
+#define TIIF_MM              0x4d4d002a
+
+static gchar * parseOrientation (GstAdapter * adapter, guint offset, guint size) {
+    guint32 tag = 0;
+    guint32 entrys =0;
+    guint32 orientation = 0;
+    guint32 offset_IFD0 = 0;
+
+    gst_adapter_masked_scan_uint32_peek (adapter, 0x0, 0x0, offset, 4, &tag);
+    if (tag != TIIF_II && tag != TIIF_MM) {
+        GST_ERROR ("invalid byte order 0x%08x", tag);
+        return NULL;
+    }
+
+    boolean littleEndian = (tag == 0x49492A00);
+    gst_adapter_masked_scan_uint32_peek (adapter, 0x0, 0x0, offset + 4, 4, &offset_IFD0);
+    offset_IFD0 = swapEndianness (offset_IFD0, littleEndian, 4);
+    GST_DEBUG ("offset_IFD0 %d", offset_IFD0);
+
+    if (offset_IFD0 < 8 || offset_IFD0 > size) {
+        GST_ERROR ("invalid offset %d",offset_IFD0);
+        return NULL;
+    }
+
+    offset += offset_IFD0;
+    gst_adapter_masked_scan_uint32_peek (adapter, 0x0, 0x0, offset, 4, &entrys);
+    entrys = swapEndianness (entrys, littleEndian, 2);
+    offset += 2;
+
+    while (entrys-- > 0 && size >= 12) {
+        gst_adapter_masked_scan_uint32_peek (adapter, 0x0, 0x0, offset, 4, &tag);
+        tag = swapEndianness(tag, littleEndian, 2);
+        if (tag == EXIF_TAG_ORIENTATION) {
+            gst_adapter_masked_scan_uint32_peek (adapter, 0x0, 0x0, offset + 8, 4, &orientation);
+            orientation = swapEndianness(orientation, littleEndian, 2);
+            GST_DEBUG ("parse orientation %d", orientation);
+            switch (orientation) {
+                case 1:
+                    return "rotate-0";
+                case 3:
+                    return "rotate-180";
+                case 6:
+                    return "rotate-90";
+                case 8:
+                    return "rotate-270";
+            }
+            GST_ERROR("unsupported orientation");
+            return NULL;
+        }
+        offset += 12;
+        size -= 12;
+    }
+    GST_ERROR ("orientation not found");
+    return NULL;
+}
+#endif
+
 static GstFlowReturn
 gst_jpeg_dec_parse (GstVideoDecoder * bdec, GstVideoCodecFrame * frame,
     GstAdapter * adapter, gboolean at_eos)
@@ -343,7 +452,7 @@ gst_jpeg_dec_parse (GstVideoDecoder * bdec, GstVideoCodecFrame * frame,
     dec->saw_header = TRUE;
   }
 
-  while (1) {
+  while (1 && dec->cancel_parse == FALSE) {
     guint frame_len;
     guint32 value;
 
@@ -393,7 +502,6 @@ gst_jpeg_dec_parse (GstVideoDecoder * bdec, GstVideoCodecFrame * frame,
       goto have_full_frame;
     }
 
-
     if (value >= 0xd0 && value <= 0xd7)
       frame_len = 0;
     else {
@@ -412,6 +520,19 @@ gst_jpeg_dec_parse (GstVideoDecoder * bdec, GstVideoCodecFrame * frame,
       goto need_more_data;
     }
 
+#ifdef TCL_PATCH
+    if (value == APP1) {
+      guint exif;
+      gst_adapter_masked_scan_uint32_peek (adapter, 0x0, 0x0, offset + 6, 4, &exif);
+      if (exif == EXIF) {
+         gchar * orientation  = parseOrientation (adapter, offset + 12, frame_len);
+         if (orientation) {
+            GstTagList *image_orientation_tag =  gst_tag_list_new (GST_TAG_IMAGE_ORIENTATION, orientation, NULL);
+            gst_pad_push_event (GST_VIDEO_DECODER_SRC_PAD (bdec), gst_event_new_tag (image_orientation_tag));
+         }
+      }
+    }
+#endif
     if (gst_jpeg_dec_parse_tag_has_entropy_segment (value)) {
       guint eseglen = dec->parse_entropy_len;
 
@@ -420,7 +541,7 @@ gst_jpeg_dec_parse (GstVideoDecoder * bdec, GstVideoCodecFrame * frame,
       if (size < offset + 2 + frame_len + eseglen)
         goto need_more_data;
       noffset = offset + 2 + frame_len + dec->parse_entropy_len;
-      while (1) {
+      while (1 && dec->cancel_parse == FALSE) {
         GST_DEBUG ("noffset:%d, size:%d, size - noffset:%d",
             noffset, size, size - noffset);
         noffset = gst_adapter_masked_scan_uint32_peek (adapter, 0x0000ff00,
@@ -436,6 +557,7 @@ gst_jpeg_dec_parse (GstVideoDecoder * bdec, GstVideoCodecFrame * frame,
         }
         noffset++;
       }
+
       dec->parse_entropy_len = 0;
       frame_len += eseglen;
       GST_DEBUG ("entropy segment length=%u => frame_len=%u", eseglen,
@@ -720,6 +842,29 @@ gst_jpeg_dec_decode_grayscale (GstJpegDec * dec, GstVideoFrame * frame,
   }
 }
 
+#ifdef TCL_PATCH
+static void
+gst_jpeg_dec_decode_cmyk (GstJpegDec * dec, GstVideoFrame * frame,
+    guint field, guint num_fields)
+{
+  gint width, height;
+  width = GST_VIDEO_FRAME_WIDTH (frame);
+  height = GST_VIDEO_FRAME_HEIGHT (frame);
+  //GST_DEBUG_OBJECT (dec, "indirect decoding of CMYK start wxh = %dx%d color = %d",dec->cinfo.output_width, dec->cinfo.output_height,dec->cinfo.out_color_space);
+  {
+    gint row_stride = GST_VIDEO_FRAME_PLANE_STRIDE (frame, 0);
+    guchar *bufbase = GST_VIDEO_FRAME_PLANE_DATA (frame, 0);
+    GST_DEBUG_OBJECT (dec,"frame size %d row_stride %d", GST_VIDEO_FRAME_SIZE(frame),row_stride);
+    while (bufbase && dec->cinfo.output_scanline < dec->cinfo.output_height) {
+      JSAMPARRAY buffer = { &bufbase, };
+      jpeg_read_scanlines (&dec->cinfo, buffer, 1);
+      bufbase += row_stride;
+    }
+  }
+  GST_DEBUG_OBJECT (dec, "indirect decoding of CMYK end");
+}
+#endif
+
 static void
 gst_jpeg_dec_decode_rgb (GstJpegDec * dec, GstVideoFrame * frame,
     guint field, guint num_fields)
@@ -1017,6 +1162,22 @@ gst_jpeg_turbo_parse_ext_fmt_convert (GstJpegDec * dec, gint * clrspc)
 {
   GstCaps *peer_caps, *dec_caps;
 
+#ifdef TCL_PATCH
+  if (dec->imageplayer){
+    if (clrspc)
+      *clrspc = JCS_RGB;
+    dec->format = GST_VIDEO_FORMAT_RGBA;
+    dec->format_convert = TRUE;
+    if(dec->cinfo.jpeg_color_space == JCS_CMYK){
+      dec->libjpeg_ext_format = JCS_CMYK;
+    } else {
+      dec->libjpeg_ext_format = JCS_EXT_RGBA;
+    }
+    GST_DEBUG ("conv to RGBA");
+    return;
+  }
+#endif
+
   dec_caps = gst_static_caps_get (&gst_jpeg_dec_src_pad_template.static_caps);
   peer_caps =
       gst_pad_peer_query_caps (GST_VIDEO_DECODER_SRC_PAD (dec), dec_caps);
@@ -1165,6 +1326,17 @@ gst_jpeg_dec_prepare_decode (GstJpegDec * dec)
 
   GST_LOG_OBJECT (dec, "r_h = %d, r_v = %d", r_h, r_v);
 
+#ifdef TCL_PATCH
+  if (dec->cinfo.num_components > 3 && dec->cinfo.jpeg_color_space != JCS_CMYK)
+    goto components_not_supported;
+
+  /* verify color space expectation to avoid going *boom* or bogus output */
+  if (dec->cinfo.jpeg_color_space != JCS_YCbCr &&
+      dec->cinfo.jpeg_color_space != JCS_GRAYSCALE &&
+      dec->cinfo.jpeg_color_space != JCS_RGB &&
+      dec->cinfo.jpeg_color_space != JCS_CMYK)
+    goto unsupported_colorspace;
+#else
   if (dec->cinfo.num_components > 3)
     goto components_not_supported;
 
@@ -1173,6 +1345,7 @@ gst_jpeg_dec_prepare_decode (GstJpegDec * dec)
       dec->cinfo.jpeg_color_space != JCS_GRAYSCALE &&
       dec->cinfo.jpeg_color_space != JCS_RGB)
     goto unsupported_colorspace;
+#endif
 
 #ifndef GST_DISABLE_GST_DEBUG
   {
@@ -1191,6 +1364,17 @@ gst_jpeg_dec_prepare_decode (GstJpegDec * dec)
   dec->cinfo.do_fancy_upsampling = FALSE;
   dec->cinfo.do_block_smoothing = FALSE;
   dec->cinfo.dct_method = dec->idct_method;
+#ifdef TCL_PATCH
+  if(dec->cinfo.num_components > 3 && dec->cinfo.image_width > 15360 && dec->cinfo.image_height > 8640){
+      GST_DEBUG_OBJECT (dec, "scale to 1/4");
+      dec->cinfo.scale_num = 1;
+      dec->cinfo.scale_denom = 4;
+  } else if(dec->cinfo.num_components == 3 && dec->cinfo.image_width >= 7680 && dec->cinfo.image_height >= 4320){
+      GST_DEBUG_OBJECT (dec, "scale to 1/2");
+      dec->cinfo.scale_num = 1;
+      dec->cinfo.scale_denom = 2;
+  }
+#endif
 #ifdef JCS_EXTENSIONS
   gst_jpeg_turbo_parse_ext_fmt_convert (dec, NULL);
   if (dec->format_convert) {
@@ -1228,6 +1412,10 @@ gst_jpeg_dec_prepare_decode (GstJpegDec * dec)
           r_h < dec->cinfo.comp_info[1].h_samp_factor)
         goto invalid_yuvrgbgrayscale;
       break;
+   case JCS_CMYK:
+      if(dec->cinfo.num_components != 4)
+        goto components_not_supported;
+      break;
     default:
       g_assert_not_reached ();
       break;
@@ -1259,6 +1447,12 @@ components_not_supported:
         ("number of components not supported: %d (max 3)",
             dec->cinfo.num_components), ret);
     jpeg_abort_decompress (&dec->cinfo);
+#ifdef TCL_PATCH
+    GError *err = g_error_new (GST_STREAM_ERROR, GST_STREAM_ERROR_DECODE, "Failed to decode JPEG image");
+    GstMessage *err_msg = gst_message_new_error (GST_OBJECT_CAST (dec), err, "number of components not supported");
+    gst_element_post_message (GST_ELEMENT (dec), err_msg);
+    g_error_free (err);
+#endif
     return GST_FLOW_ERROR;
   }
 unsupported_colorspace:
@@ -1286,24 +1480,41 @@ gst_jpeg_dec_decode (GstJpegDec * dec, GstVideoFrame * vframe, guint width,
     guint height, guint field, guint num_fields)
 {
   GstFlowReturn ret = GST_FLOW_OK;
-
+#ifdef TCL_PATCH
+  if (!dec->imageplayer && dec->cinfo.jpeg_color_space == JCS_RGB) {
+    gst_jpeg_dec_decode_rgb (dec, vframe, field, num_fields);
+  } else if (!dec->imageplayer && dec->cinfo.jpeg_color_space == JCS_GRAYSCALE) {
+    gst_jpeg_dec_decode_grayscale (dec, vframe, field, num_fields);
+  } else if (dec->cinfo.jpeg_color_space == JCS_CMYK) {
+    gst_jpeg_dec_decode_cmyk (dec, vframe, field, num_fields);
+  } else
+#else
   if (dec->cinfo.jpeg_color_space == JCS_RGB) {
     gst_jpeg_dec_decode_rgb (dec, vframe, field, num_fields);
   } else if (dec->cinfo.jpeg_color_space == JCS_GRAYSCALE) {
     gst_jpeg_dec_decode_grayscale (dec, vframe, field, num_fields);
-  } else {
+  } else
+#endif
+  {
     GST_LOG_OBJECT (dec, "decompressing (required scanline buffer height = %u)",
         dec->cinfo.rec_outbuf_height);
 
-    /* For some widths jpeglib requires more horizontal padding than I420 
+    /* For some widths jpeglib requires more horizontal padding than I420
      * provides. In those cases we need to decode into separate buffers and then
      * copy over the data into our final picture buffer, otherwise jpeglib might
      * write over the end of a line into the beginning of the next line,
      * resulting in blocky artifacts on the left side of the picture. */
+#ifdef TCL_PATCH
+    if (!dec->imageplayer && (G_UNLIKELY (width % (dec->cinfo.max_h_samp_factor * DCTSIZE) != 0
+            || dec->cinfo.comp_info[0].h_samp_factor != 2
+            || dec->cinfo.comp_info[1].h_samp_factor != 1
+            || dec->cinfo.comp_info[2].h_samp_factor != 1))) {
+#else
     if (G_UNLIKELY (width % (dec->cinfo.max_h_samp_factor * DCTSIZE) != 0
             || dec->cinfo.comp_info[0].h_samp_factor != 2
             || dec->cinfo.comp_info[1].h_samp_factor != 1
             || dec->cinfo.comp_info[2].h_samp_factor != 1)) {
+#endif
       GST_CAT_LOG_OBJECT (GST_CAT_PERFORMANCE, dec,
           "indirect decoding using extra buffer copy");
       gst_jpeg_dec_decode_indirect (dec, vframe,
@@ -1688,6 +1899,22 @@ gst_jpeg_dec_set_property (GObject * object, guint prop_id,
     case PROP_MAX_ERRORS:
       g_atomic_int_set (&dec->max_errors, g_value_get_int (value));
       break;
+#endif
+#ifdef TCL_PATCH
+    case PROP_IMAGE_PLAY:
+    {
+      gboolean imageplayer = g_value_get_boolean (value);
+      GST_INFO("set PROP_IMAGE_PLAY imageplayer = %d", imageplayer);
+      dec->imageplayer = imageplayer;
+      break;
+    }
+    case PROP_CANCEL_PARSE:
+    {
+      gboolean cancel = g_value_get_boolean (value);
+      GST_ERROR("set PROP_CANCEL_PARSE cancel = %d", cancel);
+      dec->cancel_parse = cancel;
+      break;
+    }
 #endif
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
@@ -1711,6 +1938,14 @@ gst_jpeg_dec_get_property (GObject * object, guint prop_id, GValue * value,
     case PROP_MAX_ERRORS:
       g_value_set_int (value, g_atomic_int_get (&dec->max_errors));
       break;
+#endif
+#ifdef TCL_PATCH
+    case PROP_IMAGE_PLAY:
+     g_value_set_boolean (value, dec->imageplayer);
+     break;
+    case PROP_CANCEL_PARSE:
+     g_value_set_boolean (value, dec->cancel_parse);
+     break;
 #endif
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
diff --git a/subprojects/gst-plugins-good/ext/jpeg/gstjpegdec.h b/subprojects/gst-plugins-good/ext/jpeg/gstjpegdec.h
index b16f802a87..96cdcfb633 100644
--- a/subprojects/gst-plugins-good/ext/jpeg/gstjpegdec.h
+++ b/subprojects/gst-plugins-good/ext/jpeg/gstjpegdec.h
@@ -86,6 +86,11 @@ struct _GstJpegDec {
   gint     parse_entropy_len;
   gint     parse_resync;
 
+#ifdef TCL_PATCH
+  gboolean imageplayer;
+  gboolean cancel_parse;
+#endif
+
   /* properties */
   gint     idct_method;
   gint     max_errors;  /* ATOMIC */
diff --git a/subprojects/gst-plugins-good/ext/jpeg/meson.build b/subprojects/gst-plugins-good/ext/jpeg/meson.build
index 8f63454d48..d29b5cc444 100644
--- a/subprojects/gst-plugins-good/ext/jpeg/meson.build
+++ b/subprojects/gst-plugins-good/ext/jpeg/meson.build
@@ -6,7 +6,7 @@ jpeg_sources = [
 ]
 
 jpeglib = dependency('libjpeg', required : get_option('jpeg'),
-  fallback: ['libjpeg-turbo', 'jpeg_dep'])
+  fallback: ['libjpeg-turbo', 'jpeg_dep'], static: true)
 
 if jpeglib.found()
   gstjpeg = library('gstjpeg',
diff --git a/subprojects/gst-plugins-good/ext/libpng/gstpngdec.c b/subprojects/gst-plugins-good/ext/libpng/gstpngdec.c
index 5f6dc8f88a..89366e2961 100644
--- a/subprojects/gst-plugins-good/ext/libpng/gstpngdec.c
+++ b/subprojects/gst-plugins-good/ext/libpng/gstpngdec.c
@@ -62,8 +62,13 @@ static gboolean gst_pngdec_sink_event (GstVideoDecoder * bdec,
 
 #define parent_class gst_pngdec_parent_class
 G_DEFINE_TYPE (GstPngDec, gst_pngdec, GST_TYPE_VIDEO_DECODER);
+#ifdef TCL_PATCH
+GST_ELEMENT_REGISTER_DEFINE (pngdec, "pngdec", GST_RANK_MARGINAL,
+    GST_TYPE_PNGDEC);
+#else
 GST_ELEMENT_REGISTER_DEFINE (pngdec, "pngdec", GST_RANK_PRIMARY,
     GST_TYPE_PNGDEC);
+#endif
 
 static GstStaticPadTemplate gst_pngdec_src_pad_template =
 GST_STATIC_PAD_TEMPLATE ("src",
@@ -183,7 +188,7 @@ user_endrow_callback (png_structp png_ptr, png_bytep new_row,
 
   pngdec = GST_PNGDEC (png_get_io_ptr (png_ptr));
 
-  /* If buffer_out doesn't exist, it means buffer_alloc failed, which 
+  /* If buffer_out doesn't exist, it means buffer_alloc failed, which
    * will already have set the return code */
   if (new_row && GST_IS_BUFFER (pngdec->current_frame->output_buffer)) {
     GstVideoFrame frame;
diff --git a/subprojects/gst-plugins-good/ext/soup/gstsouploader.c b/subprojects/gst-plugins-good/ext/soup/gstsouploader.c
index 549b81fd25..f126b8a898 100644
--- a/subprojects/gst-plugins-good/ext/soup/gstsouploader.c
+++ b/subprojects/gst-plugins-good/ext/soup/gstsouploader.c
@@ -40,8 +40,8 @@ GST_DEBUG_CATEGORY (gst_soup_debug);
 #define LIBSOUP_3_SONAME "libsoup-3.0.0.dylib"
 #define LIBSOUP_2_SONAME "libsoup-2.4.1.dylib"
 #else
-#define LIBSOUP_3_SONAME "libsoup-3.0.so.0"
-#define LIBSOUP_2_SONAME "libsoup-2.4.so.1"
+#define LIBSOUP_3_SONAME "libsoup-3.0.so"
+#define LIBSOUP_2_SONAME "libsoup-2.4.so"
 #endif
 
 
diff --git a/subprojects/gst-plugins-good/gst/audioparsers/gstaacparse.c b/subprojects/gst-plugins-good/gst/audioparsers/gstaacparse.c
index 28e953ef58..be818114bb 100644
--- a/subprojects/gst-plugins-good/gst/audioparsers/gstaacparse.c
+++ b/subprojects/gst-plugins-good/gst/audioparsers/gstaacparse.c
@@ -65,6 +65,10 @@ static GstStaticPadTemplate sink_template = GST_STATIC_PAD_TEMPLATE ("sink",
 GST_DEBUG_CATEGORY_STATIC (aacparse_debug);
 #define GST_CAT_DEFAULT aacparse_debug
 
+#ifdef TCL_PATCH
+#define DEFAULT_INVALID_FRAMES                  1024
+#define DEFAULT_INVALID_TIME_DIFFERENCE        3000000000     // 3秒钟时间差
+#endif
 
 #define ADIF_MAX_SIZE 40        /* Should be enough */
 #define ADTS_MAX_SIZE 10        /* Should be enough */
@@ -159,6 +163,12 @@ gst_aac_parse_init (GstAacParse * aacparse)
 
   aacparse->last_parsed_sample_rate = 0;
   aacparse->last_parsed_channels = 0;
+#ifdef TCL_PATCH
+  aacparse->invalid_frames = 0;
+  aacparse->first_invalid_frames_PTS_valid = TRUE;
+  aacparse->invalid_frames_starttime = 0;
+  aacparse->set_caps_flag = FALSE;
+#endif
 }
 
 
@@ -226,8 +236,13 @@ gst_aac_parse_set_src_caps (GstAacParse * aacparse, GstCaps * sink_caps)
   s = gst_caps_get_structure (src_caps, 0);
   if (aacparse->sample_rate > 0)
     gst_structure_set (s, "rate", G_TYPE_INT, aacparse->sample_rate, NULL);
+#ifdef TCL_PATCH
+  if ((aacparse->channels > 0) || (aacparse->header_type == DSPAAC_HEADER_ADTS && aacparse->channels == 0))
+    gst_structure_set (s, "channels", G_TYPE_INT, aacparse->channels, NULL);
+#else
   if (aacparse->channels > 0)
     gst_structure_set (s, "channels", G_TYPE_INT, aacparse->channels, NULL);
+#endif
   if (stream_format)
     gst_structure_set (s, "stream-format", G_TYPE_STRING, stream_format, NULL);
 
@@ -314,6 +329,9 @@ gst_aac_parse_sink_setcaps (GstBaseParse * parse, GstCaps * caps)
    * Parses the codec_data information to get ObjectType,
    * number of channels and samplerate */
   value = gst_structure_get_value (structure, "codec_data");
+#ifdef TCL_PATCH
+  gst_structure_get_boolean(structure, "codec_set", &aacparse->codec_set);
+#endif
   if (value) {
     GstBuffer *buf = gst_value_get_buffer (value);
 
@@ -584,8 +602,15 @@ gst_aac_parse_read_audio_specific_config (GstAacParse * aacparse,
     GST_LOG_OBJECT (aacparse,
         "Audio object type 5 or 29, so rereading sampling rate (was %d)...",
         *sample_rate);
+#ifdef TCL_PATCH
+    gint sample_rate_temp;
+    if (!gst_aac_parse_get_audio_sample_rate (aacparse, br, &sample_rate_temp))
+      return FALSE;
+    GST_INFO("sample_rate = %d sample_rate_temp == %d", *sample_rate, sample_rate_temp);
+#elif
     if (!gst_aac_parse_get_audio_sample_rate (aacparse, br, sample_rate))
       return FALSE;
+#endif
 
     if (!gst_aac_parse_get_audio_object_type (aacparse, br, &audio_object_type))
       return FALSE;
@@ -924,10 +949,18 @@ gst_aac_parse_detect_stream (GstAacParse * aacparse,
     gst_aac_parse_parse_adts_header (aacparse, data, &rate, &channels,
         &aacparse->object_type, &aacparse->mpegversion);
 
-    if (!channels || !framesize) {
+#ifdef TCL_PATCH
+    if (!framesize /* || !channels  channel may be is zero for some audio
+    stream,modified by chenyz in 20160317.*/ ) {
       GST_DEBUG_OBJECT (aacparse, "impossible ADTS configuration");
       return FALSE;
     }
+#else
+    if (!framesize || !channels) {
+      GST_DEBUG_OBJECT (aacparse, "impossible ADTS configuration");
+      return FALSE;
+    }
+#endif
 
     aacparse->header_type = DSPAAC_HEADER_ADTS;
     gst_base_parse_set_frame_rate (GST_BASE_PARSE (aacparse), rate,
@@ -1309,7 +1342,22 @@ gst_aac_parse_handle_frame (GstBaseParse * parse,
 
     ret = gst_aac_parse_detect_stream (aacparse, map.data, map.size,
         GST_BASE_PARSE_DRAINING (parse), &framesize, skipsize);
-
+#ifdef TCL_PATCH
+    if (!ret)
+    {
+        GstCaps *sinkcaps = gst_pad_get_current_caps(parse->sinkpad);
+        if (sinkcaps != NULL)
+        {
+            GstStructure *srcstruct;
+            guint16 stream_pid = 0;
+            srcstruct = gst_caps_get_structure (sinkcaps, 0);
+            gst_structure_get_int(srcstruct,"stream_pid", &stream_pid);
+            gst_caps_unref(sinkcaps);
+            if (stream_pid == 517)
+                goto error;
+        }
+    }
+#endif
   } else if (aacparse->header_type == DSPAAC_HEADER_ADTS) {
     guint needed_data = 1024;
 
@@ -1431,10 +1479,72 @@ exit:
   }
 
   if (ret && framesize <= map.size) {
+#ifdef TCL_PATCH
+    aacparse->invalid_frames = 0;
+    aacparse->first_invalid_frames_PTS_valid = TRUE;
+    aacparse->invalid_frames_starttime = 0;
+#endif
     return gst_base_parse_finish_frame (parse, frame, framesize);
   }
 
   return GST_FLOW_OK;
+#ifdef TCL_PATCH
+error:
+  *skipsize = 0;
+  gst_buffer_unmap (buffer, &map);
+  // Caps简单协商，否则管道为NOT LINKED的
+  if(FALSE == aacparse->set_caps_flag){
+      gboolean ret   = TRUE;
+      const gchar  *stream_format;
+      GstStructure *s    = NULL;
+      GstCaps *src_caps = gst_caps_new_empty_simple ("audio/mpeg");
+
+      if(aacparse->mpegversion == 0){
+        aacparse->mpegversion = 4;
+      }
+
+      gst_caps_set_simple (src_caps, "framed", G_TYPE_BOOLEAN, TRUE,
+          "mpegversion", G_TYPE_INT, aacparse->mpegversion, NULL);
+      aacparse->output_header_type = aacparse->header_type;
+      switch (aacparse->header_type) {
+        case DSPAAC_HEADER_NONE:
+          stream_format = "raw";
+          break;
+        case DSPAAC_HEADER_ADTS:
+          stream_format = "adts";
+          break;
+        case DSPAAC_HEADER_ADIF:
+          stream_format = "adif";
+          break;
+        case DSPAAC_HEADER_LOAS:
+          stream_format = "loas";
+          break;
+        default:
+          stream_format = NULL;
+      }
+      s = gst_caps_get_structure (src_caps, 0);
+      if (aacparse->sample_rate > 0)
+        gst_structure_set (s, "rate", G_TYPE_INT, aacparse->sample_rate, NULL);
+      if (aacparse->channels > 0)
+        gst_structure_set (s, "channels", G_TYPE_INT, aacparse->channels, NULL);
+      if (stream_format)
+        gst_structure_set (s, "stream-format", G_TYPE_STRING, stream_format, NULL);
+
+      GST_DEBUG_OBJECT (aacparse, "setting src caps: %" GST_PTR_FORMAT, src_caps);
+
+      ret = gst_pad_set_caps (GST_BASE_PARSE (aacparse)->srcpad, src_caps);
+      gst_caps_unref (src_caps);
+      if (!ret) {
+        GST_ERROR_OBJECT (aacparse, "GST_FLOW_NOT_LINKED!");
+        return GST_FLOW_NOT_LINKED;
+      } else {
+        aacparse->set_caps_flag = TRUE;
+        GST_ERROR_OBJECT (aacparse, "gst_aac_parse_set_src_caps!");
+      }
+  }
+  gst_base_parse_finish_frame (parse, frame, framesize);
+  return GST_FLOW_OK;
+#endif
 }
 
 static GstFlowReturn
@@ -1459,8 +1569,14 @@ gst_aac_parse_pre_push_frame (GstBaseParse * parse, GstBaseParseFrame * frame)
     }
 
     taglist = gst_tag_list_new_empty ();
+#ifdef TCL_PATCH
+    if (!aacparse->codec_set)
+        gst_pb_utils_add_codec_description_to_tag_list (taglist,
+            GST_TAG_AUDIO_CODEC, caps);
+#else
     gst_pb_utils_add_codec_description_to_tag_list (taglist,
-        GST_TAG_AUDIO_CODEC, caps);
+                GST_TAG_AUDIO_CODEC, caps);
+#endif
     gst_caps_unref (caps);
 
     gst_base_parse_merge_tags (parse, taglist, GST_TAG_MERGE_REPLACE);
@@ -1516,6 +1632,7 @@ gst_aac_parse_start (GstBaseParse * parse)
   aacparse->output_header_type = DSPAAC_HEADER_NOT_PARSED;
   aacparse->channels = 0;
   aacparse->sample_rate = 0;
+  aacparse->codec_set = FALSE;
   return TRUE;
 }
 
diff --git a/subprojects/gst-plugins-good/gst/audioparsers/gstaacparse.h b/subprojects/gst-plugins-good/gst/audioparsers/gstaacparse.h
index 40c96ff1f8..7c9ee86588 100644
--- a/subprojects/gst-plugins-good/gst/audioparsers/gstaacparse.h
+++ b/subprojects/gst-plugins-good/gst/audioparsers/gstaacparse.h
@@ -86,6 +86,14 @@ struct _GstAacParse {
 
   gint last_parsed_sample_rate;
   gint last_parsed_channels;
+
+#ifdef TCL_PATCH
+  gint           invalid_frames;                        // 无效帧数
+  GstClockTime   invalid_frames_starttime;             // 第一个无效帧起始时间
+  gboolean       first_invalid_frames_PTS_valid;      // 第一个无效帧的PTS是否有效
+  gboolean       codec_set;
+  gboolean       set_caps_flag;                        // 是否设置了caps
+#endif
 };
 
 /**
diff --git a/subprojects/gst-plugins-good/gst/audioparsers/gstac3parse.c b/subprojects/gst-plugins-good/gst/audioparsers/gstac3parse.c
index 64b3ca3c1e..05dc6fd039 100644
--- a/subprojects/gst-plugins-good/gst/audioparsers/gstac3parse.c
+++ b/subprojects/gst-plugins-good/gst/audioparsers/gstac3parse.c
@@ -49,10 +49,17 @@
 #include "gstac3parse.h"
 #include <gst/base/base.h>
 #include <gst/pbutils/pbutils.h>
+#include <gst/gstpad.h>
 
 GST_DEBUG_CATEGORY_STATIC (ac3_parse_debug);
 #define GST_CAT_DEFAULT ac3_parse_debug
 
+#ifdef TCL_PATCH
+#define DEFAULT_INVALID_FRAMES   64
+#define PSR_C2 (2)
+#define AC3_STREAM_TYPE_DEPEND (1)
+#endif
+
 static const struct
 {
   const guint bit_rate;         /* nominal bit rate */
@@ -147,14 +154,20 @@ static GstStaticPadTemplate src_template = GST_STATIC_PAD_TEMPLATE ("src",
     GST_STATIC_CAPS ("audio/x-ac3, framed = (boolean) true, "
         " channels = (int) [ 1, 6 ], rate = (int) [ 8000, 48000 ], "
         " alignment = (string) { iec61937, frame}; "
+        "audio/x-dts-ac3, "
+        " channels = (int) [ 1, 6 ], rate = (int) [ 8000, 48000 ]; "
         "audio/x-eac3, framed = (boolean) true, "
+#ifdef TCL_PATCH
+        " channels = (int) [ 1, 8 ], rate = (int) [ 8000, 48000 ], "
+#else
         " channels = (int) [ 1, 6 ], rate = (int) [ 8000, 48000 ], "
+#endif
         " alignment = (string) { iec61937, frame}; "));
 
 static GstStaticPadTemplate sink_template = GST_STATIC_PAD_TEMPLATE ("sink",
     GST_PAD_SINK,
     GST_PAD_ALWAYS,
-    GST_STATIC_CAPS ("audio/x-ac3; " "audio/x-eac3; " "audio/ac3; "
+    GST_STATIC_CAPS ("audio/x-ac3; " "audio/x-dts-ac3; " "audio/x-eac3; " "audio/ac3; "
         "audio/x-private1-ac3"));
 
 static void gst_ac3_parse_finalize (GObject * object);
@@ -214,6 +227,21 @@ gst_ac3_parse_reset (GstAc3Parse * ac3parse)
   ac3parse->blocks = -1;
   ac3parse->eac = FALSE;
   ac3parse->sent_codec_tag = FALSE;
+#ifdef TCL_PATCH
+  ac3parse->subformat = -1;
+  ac3parse->stream_id = -1;
+#endif
+#ifdef TCL_PATCH
+  ac3parse->invalid_frames = 0 ;
+  ac3parse->dts_channels = -1;
+  ac3parse->dts_rate = -1;
+  ac3parse->dts_depth = -1;
+  ac3parse->dts_endianness = -1;
+  ac3parse->dts_block_size = -1;
+  ac3parse->dts_frame_size = -1;
+  ac3parse->dts_last_sync = 0;
+  ac3parse->dts_sent_codec_tag = FALSE;
+#endif
   g_atomic_int_set (&ac3parse->align, GST_AC3_PARSE_ALIGN_NONE);
 }
 
@@ -424,12 +452,24 @@ gst_ac3_parse_frame_header_eac3 (GstAc3Parse * ac3parse, GstBuffer * buf,
     *frame_size = (frmsiz + 1) * 2;
   if (rate)
     *rate = sample_rate;
+#if 0 //fpp
+  if (chans)
+    *chans = acmod_chans[acmod];
+#else
   if (chans)
     *chans = acmod_chans[acmod] + lfe_on;
+#endif
   if (blks)
     *blks = blocks;
   if (sid)
     *sid = (strmtyp & 0x1) << 3 | strmid;
+#ifdef TCL_PATCH
+  if (ac3parse->subformat == AC3_STREAM_TYPE_DEPEND && ac3parse->stream_id == 0 && *chans == 6) {
+    *chans = *chans + PSR_C2; //2 for 7.1 case
+  }
+  ac3parse->subformat = strmtyp;
+  ac3parse->stream_id = strmid;
+#endif
 
   ret = TRUE;
 
@@ -492,6 +532,285 @@ cleanup:
   return ret;
 }
 
+#ifdef TCL_PATCH
+static gint
+gst_dts_parse_find_sync (GstAc3Parse * parse, GstByteReader * reader,
+    gsize bufsize, guint32 * sync)
+{
+  guint32 best_sync = 0;
+  guint best_offset = G_MAXUINT;
+  gint off;
+
+  /* FIXME: verify syncs via _parse_header() here already */
+
+  /* Raw little endian */
+  off = gst_byte_reader_masked_scan_uint32 (reader, 0xffffffff, 0xfe7f0180,
+      0, bufsize);
+  if (off >= 0 && off < best_offset) {
+    best_offset = off;
+    best_sync = 0xfe7f0180;
+  }
+
+  /* Raw big endian */
+  off = gst_byte_reader_masked_scan_uint32 (reader, 0xffffffff, 0x7ffe8001,
+      0, bufsize);
+  if (off >= 0 && off < best_offset) {
+    best_offset = off;
+    best_sync = 0x7ffe8001;
+  }
+
+  /* FIXME: check next 2 bytes as well for 14-bit formats (but then don't
+   * forget to adjust the *skipsize= in _check_valid_frame() */
+
+  /* 14-bit little endian  */
+  off = gst_byte_reader_masked_scan_uint32 (reader, 0xffffffff, 0xff1f00e8,
+      0, bufsize);
+  if (off >= 0 && off < best_offset) {
+    best_offset = off;
+    best_sync = 0xff1f00e8;
+  }
+
+  /* 14-bit big endian  */
+  off = gst_byte_reader_masked_scan_uint32 (reader, 0xffffffff, 0x1fffe800,
+      0, bufsize);
+  if (off >= 0 && off < best_offset) {
+    best_offset = off;
+    best_sync = 0x1fffe800;
+  }
+
+  if (best_offset == G_MAXUINT)
+    return -1;
+
+  *sync = best_sync;
+  return best_offset;
+}
+
+static gboolean
+gst_dts_parse_parse_header (GstAc3Parse * parse,
+    const GstByteReader * reader, guint * frame_size,
+    guint * sample_rate, guint * channels, guint * depth,
+    gint * endianness, guint * num_blocks, guint * samples_per_block,
+    gboolean * terminator)
+{
+  static const int sample_rates[16] = { 0, 8000, 16000, 32000, 0, 0, 11025,
+    22050, 44100, 0, 0, 12000, 24000, 48000, 96000, 192000
+  };
+  static const guint8 channels_table[16] = { 1, 2, 2, 2, 2, 3, 3, 4, 4, 5,
+    6, 6, 6, 7, 8, 8
+  };
+  GstByteReader r = *reader;
+  guint16 hdr[8];
+  guint32 marker;
+  guint chans, lfe, i;
+
+  if (gst_byte_reader_get_remaining (&r) < (4 + sizeof (hdr)))
+    return FALSE;
+
+  marker = gst_byte_reader_peek_uint32_be_unchecked (&r);
+
+  /* raw big endian or 14-bit big endian */
+  if (marker == 0x7FFE8001 || marker == 0x1FFFE800) {
+    for (i = 0; i < G_N_ELEMENTS (hdr); ++i)
+      hdr[i] = gst_byte_reader_get_uint16_be_unchecked (&r);
+  } else
+    /* raw little endian or 14-bit little endian */
+  if (marker == 0xFE7F0180 || marker == 0xFF1F00E8) {
+    for (i = 0; i < G_N_ELEMENTS (hdr); ++i)
+      hdr[i] = gst_byte_reader_get_uint16_le_unchecked (&r);
+  } else {
+    return FALSE;
+  }
+
+  GST_LOG_OBJECT (parse, "dts sync marker 0x%08x at offset %u", marker,
+      gst_byte_reader_get_pos (reader));
+
+  /* 14-bit mode */
+  if (marker == 0x1FFFE800 || marker == 0xFF1F00E8) {
+    if ((hdr[2] & 0xFFF0) != 0x07F0)
+      return FALSE;
+    /* discard top 2 bits (2 void), shift in 2 */
+    hdr[0] = (hdr[0] << 2) | ((hdr[1] >> 12) & 0x0003);
+    /* discard top 4 bits (2 void, 2 shifted into hdr[0]), shift in 4 etc. */
+    hdr[1] = (hdr[1] << 4) | ((hdr[2] >> 10) & 0x000F);
+    hdr[2] = (hdr[2] << 6) | ((hdr[3] >> 8) & 0x003F);
+    hdr[3] = (hdr[3] << 8) | ((hdr[4] >> 6) & 0x00FF);
+    hdr[4] = (hdr[4] << 10) | ((hdr[5] >> 4) & 0x03FF);
+    hdr[5] = (hdr[5] << 12) | ((hdr[6] >> 2) & 0x0FFF);
+    hdr[6] = (hdr[6] << 14) | ((hdr[7] >> 0) & 0x3FFF);
+    g_assert (hdr[0] == 0x7FFE && hdr[1] == 0x8001);
+  }
+
+  GST_LOG_OBJECT (parse, "frame header: %04x%04x%04x%04x",
+      hdr[2], hdr[3], hdr[4], hdr[5]);
+
+  *terminator = (hdr[2] & 0x80) ? FALSE : TRUE;
+  *samples_per_block = ((hdr[2] >> 10) & 0x1f) + 1;
+  *num_blocks = ((hdr[2] >> 2) & 0x7F) + 1;
+  *frame_size = (((hdr[2] & 0x03) << 12) | (hdr[3] >> 4)) + 1;
+  chans = ((hdr[3] & 0x0F) << 2) | (hdr[4] >> 14);
+  *sample_rate = sample_rates[(hdr[4] >> 10) & 0x0F];
+  lfe = (hdr[5] >> 9) & 0x03;
+
+  GST_TRACE_OBJECT (parse, "frame size %u, num_blocks %u, rate %u, "
+      "samples per block %u", *frame_size, *num_blocks, *sample_rate,
+      *samples_per_block);
+
+  if (*num_blocks < 6 || *frame_size < 96 || *sample_rate == 0)
+    return FALSE;
+
+  if (marker == 0x1FFFE800 || marker == 0xFF1F00E8)
+    *frame_size = (*frame_size * 16) / 14;      /* FIXME: round up? */
+
+  if (chans < G_N_ELEMENTS (channels_table))
+    *channels = channels_table[chans] + ((lfe) ? 1 : 0);
+  else
+    return FALSE;
+
+  if (depth)
+    *depth = (marker == 0x1FFFE800 || marker == 0xFF1F00E8) ? 14 : 16;
+  if (endianness)
+    *endianness = (marker == 0xFE7F0180 || marker == 0xFF1F00E8) ?
+        G_LITTLE_ENDIAN : G_BIG_ENDIAN;
+
+  GST_TRACE_OBJECT (parse, "frame size %u, channels %u, rate %u, "
+      "num_blocks %u, samples_per_block %u", *frame_size, *channels,
+      *sample_rate, *num_blocks, *samples_per_block);
+
+  return TRUE;
+}
+
+static GstFlowReturn
+gst_dts_parse_handle_frame (GstBaseParse * parse,
+    GstBaseParseFrame * frame, gint * skipsize)
+{
+  GstAc3Parse *ac3parse = GST_AC3_PARSE (parse);
+  GstBuffer *buf = frame->buffer;
+  GstByteReader r;
+  gboolean parser_in_sync;
+  gboolean terminator;
+  guint32 sync = 0;
+  guint size = 0, rate, chans, num_blocks, samples_per_block, depth;
+  gint block_size;
+  gint endianness;
+  gint off = -1;
+  GstMapInfo map;
+  GstFlowReturn ret = GST_FLOW_EOS;
+  gsize extra_size = 0;
+
+  gst_buffer_map (buf, &map, GST_MAP_READ);
+
+  if (G_UNLIKELY (map.size < 16)) {
+    *skipsize = 1;
+    goto cleanup;
+  }
+
+  parser_in_sync = !GST_BASE_PARSE_LOST_SYNC (parse);
+
+  gst_byte_reader_init (&r, map.data, map.size);
+
+  if (G_LIKELY (parser_in_sync && ac3parse->dts_last_sync != 0)) {
+    off = gst_byte_reader_masked_scan_uint32 (&r, 0xffffffff,
+        ac3parse->dts_last_sync, 0, map.size);
+  }
+
+  if (G_UNLIKELY (off < 0)) {
+    off = gst_dts_parse_find_sync (ac3parse, &r, map.size, &sync);
+  }
+
+  /* didn't find anything that looks like a sync word, skip */
+  if (off < 0) {
+    *skipsize = map.size - 3;
+    GST_DEBUG_OBJECT (ac3parse, "no sync, skipping %d bytes", *skipsize);
+    goto cleanup;
+  }
+
+  GST_DEBUG_OBJECT (parse, "possible sync %08x at buffer offset %d", sync, off);
+
+  /* possible frame header, but not at offset 0? skip bytes before sync */
+  if (off > 0) {
+    *skipsize = off;
+    goto cleanup;
+  }
+
+  /* make sure the values in the frame header look sane */
+  if (!gst_dts_parse_parse_header (ac3parse, &r, &size, &rate, &chans, &depth,
+          &endianness, &num_blocks, &samples_per_block, &terminator)) {
+    *skipsize = 4;
+    goto cleanup;
+  }
+
+  GST_DEBUG_OBJECT (parse, "got frame, sync %08x, size %u, rate %d, channels %d",
+      sync, size, rate, chans);
+
+  ac3parse->dts_last_sync = sync;
+
+  /* found frame */
+  ret = GST_FLOW_OK;
+
+  /* metadata handling */
+  block_size = num_blocks * samples_per_block;
+
+  if (G_UNLIKELY (ac3parse->dts_rate != rate || ac3parse->dts_channels != chans
+          || ac3parse->dts_depth != depth || ac3parse->dts_endianness != endianness
+          || (!terminator && ac3parse->dts_block_size != block_size)
+          || (size != ac3parse->dts_frame_size))) {
+    GstCaps *caps;
+    GST_ERROR_OBJECT (parse, "in ac3parse, we set dts caps");
+    caps = gst_caps_new_simple ("audio/x-dts-ac3",
+        "rate", G_TYPE_INT, rate,
+        "channels", G_TYPE_INT, chans, NULL);
+
+    gst_pad_set_caps (GST_BASE_PARSE_SRC_PAD (parse), caps);
+    gst_caps_unref (caps);
+
+    ac3parse->dts_rate = rate;
+    ac3parse->dts_channels = chans;
+    ac3parse->dts_depth = depth;
+    ac3parse->dts_endianness = endianness;
+    ac3parse->dts_block_size = block_size;
+    ac3parse->dts_frame_size = size;
+
+    gst_base_parse_set_frame_rate (parse, rate, block_size, 0, 0);
+  }
+
+cleanup:
+  /* it is possible that DTS HD substream after DTS core */
+  if (parse->flags & GST_BASE_PARSE_FLAG_DRAINING || map.size >= size + 9) {
+    extra_size = 0;
+    if (map.size >= size + 9) {
+      const guint8 *next = map.data + size;
+      /* Check for DTS_SYNCWORD_SUBSTREAM */
+      if (next[0] == 0x64 && next[1] == 0x58 && next[2] == 0x20
+          && next[3] == 0x25) {
+        /* 7.4.1 Extension Substream Header */
+        GstBitReader reader;
+        gst_bit_reader_init (&reader, next + 4, 5);
+        gst_bit_reader_skip (&reader, 8 + 2);   /* skip UserDefinedBits and nExtSSIndex) */
+        if (gst_bit_reader_get_bits_uint8_unchecked (&reader, 1) == 0) {
+          gst_bit_reader_skip (&reader, 8);
+          extra_size =
+              gst_bit_reader_get_bits_uint32_unchecked (&reader, 16) + 1;
+        } else {
+          gst_bit_reader_skip (&reader, 12);
+          extra_size =
+              gst_bit_reader_get_bits_uint32_unchecked (&reader, 20) + 1;
+        }
+      }
+    }
+    gst_buffer_unmap (buf, &map);
+    if (ret == GST_FLOW_OK && size + extra_size <= map.size) {
+      ret = gst_base_parse_finish_frame (parse, frame, size + extra_size);
+    } else {
+      ret = GST_FLOW_OK;
+    }
+  } else {
+    gst_buffer_unmap (buf, &map);
+  }
+
+  return ret;
+}
+#endif
+
 static GstFlowReturn
 gst_ac3_parse_handle_frame (GstBaseParse * parse,
     GstBaseParseFrame * frame, gint * skipsize)
@@ -510,6 +829,8 @@ gst_ac3_parse_handle_frame (GstBaseParse * parse,
   gboolean ret = FALSE;
   GstFlowReturn res = GST_FLOW_OK;
 
+  guint32 sync = 0;
+
   gst_buffer_map (buf, &map, GST_MAP_READ);
 
   if (G_UNLIKELY (map.size < 8)) {
@@ -518,14 +839,34 @@ gst_ac3_parse_handle_frame (GstBaseParse * parse,
   }
 
   gst_byte_reader_init (&reader, map.data, map.size);
-  off = gst_byte_reader_masked_scan_uint32 (&reader, 0xffff0000, 0x0b770000,
+
+ off = gst_byte_reader_masked_scan_uint32 (&reader, 0xffff0000, 0x0b770000,
       0, map.size);
 
   GST_LOG_OBJECT (parse, "possible sync at buffer offset %d", off);
 
+#ifdef TCL_PATCH
+  if (off < 0) {
+      off = gst_dts_parse_find_sync (ac3parse, &reader, map.size, &sync);
+      if (off >= 0) {
+        gst_buffer_unmap (buf, &map);
+        res = gst_dts_parse_handle_frame(parse, frame, skipsize);
+        return res;
+      }
+  }
+  if(ac3parse->invalid_frames > DEFAULT_INVALID_FRAMES) {
+    ac3parse->invalid_frames = 0;
+    gst_base_parse_set_drop_stream (parse, TRUE);
+    goto cleanup;
+  }
+#endif
+
   /* didn't find anything that looks like a sync word, skip */
   if (off < 0) {
     *skipsize = map.size - 3;
+#ifdef TCL_PATCH
+    ac3parse->invalid_frames++;
+#endif
     goto cleanup;
   }
 
@@ -646,6 +987,15 @@ gst_ac3_parse_handle_frame (GstBaseParse * parse,
     gst_caps_set_simple (caps, "alignment", G_TYPE_STRING,
         g_atomic_int_get (&ac3parse->align) == GST_AC3_PARSE_ALIGN_IEC61937 ?
         "iec61937" : "frame", NULL);
+#ifdef TCL_PATCH
+    GstCaps *sink_pad_caps = gst_pad_get_current_caps(parse->sinkpad);
+    char* caps_info = gst_caps_to_string(sink_pad_caps);
+    GstStructure *structure = gst_caps_get_structure(sink_pad_caps, 0);
+    gint bitrate = 0;
+    gst_structure_get_int (structure, "bit_rate",  &bitrate);
+    gst_caps_set_simple (caps, "bitrate", G_TYPE_INT, bitrate, NULL);
+#endif
+
     gst_pad_set_caps (GST_BASE_PARSE_SRC_PAD (parse), caps);
     gst_caps_unref (caps);
 
@@ -669,6 +1019,9 @@ cleanup:
   gst_buffer_unmap (buf, &map);
 
   if (ret && framesize <= map.size) {
+#ifdef TCL_PATCH
+    ac3parse->invalid_frames = 0;
+#endif
     res = gst_base_parse_finish_frame (parse, frame, framesize);
   }
 
diff --git a/subprojects/gst-plugins-good/gst/audioparsers/gstac3parse.h b/subprojects/gst-plugins-good/gst/audioparsers/gstac3parse.h
index 81e2104d5e..e8e84cd5f9 100644
--- a/subprojects/gst-plugins-good/gst/audioparsers/gstac3parse.h
+++ b/subprojects/gst-plugins-good/gst/audioparsers/gstac3parse.h
@@ -64,6 +64,21 @@ struct _GstAc3Parse {
   gboolean              sent_codec_tag;
   gint                  align;
   GstPadChainFunction   baseparse_chainfunc;
+#ifdef TCL_PATCH
+  gint                  subformat;
+  gint                  stream_id;
+#endif
+#ifdef TCL_PATCH
+  gint                  invalid_frames;
+  gint                  dts_channels;
+  gint                  dts_rate;
+  gint                  dts_depth;
+  gint                  dts_endianness;
+  gint                  dts_block_size;
+  gint                  dts_frame_size;
+  gboolean              dts_sent_codec_tag;
+  guint32               dts_last_sync;
+#endif
 };
 
 /**
diff --git a/subprojects/gst-plugins-good/gst/audioparsers/gstac4parse.c b/subprojects/gst-plugins-good/gst/audioparsers/gstac4parse.c
new file mode 100755
index 0000000000..1a4b4200a4
--- /dev/null
+++ b/subprojects/gst-plugins-good/gst/audioparsers/gstac4parse.c
@@ -0,0 +1,397 @@
+/********************************************************************************
+** Copyright (C), 2014-2021, TCL TV Comm Corp., Ltd
+** VENDOR_EDIT, All rights reserved.
+**
+** File: - gstac4parse.c
+** Description:
+**    define parse ac4 struct
+**
+** ------------------------------- Revision History: ---------------------------
+** <author>            <date>       <version>      <desc>
+** -----------------------------------------------------------------------------
+*******************************************************************************/
+
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <string.h>
+
+#include "gstaudioparserselements.h"
+#include "gstac4parse.h"
+#include <gst/base/base.h>
+#include <gst/pbutils/pbutils.h>
+
+GST_DEBUG_CATEGORY_STATIC (ac4_parse_debug);
+#define GST_CAT_DEFAULT ac4_parse_debug
+
+static GstStaticPadTemplate src_template = GST_STATIC_PAD_TEMPLATE ("src",
+    GST_PAD_SRC,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS ("audio/x-ac4-tcl, framed = (boolean) true, "
+        " channels = (int) [ 1, 6 ]; "));
+
+static GstStaticPadTemplate sink_template = GST_STATIC_PAD_TEMPLATE ("sink",
+    GST_PAD_SINK,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS ("audio/x-ac4-tcl; " ));
+
+static void gst_ac4_parse_finalize (GObject * object);
+
+static gboolean gst_ac4_parse_start (GstBaseParse * parse);
+static gboolean gst_ac4_parse_stop (GstBaseParse * parse);
+static GstFlowReturn gst_ac4_parse_handle_frame (GstBaseParse * parse,
+    GstBaseParseFrame * frame, gint * skipsize);
+static GstFlowReturn gst_ac4_parse_pre_push_frame (GstBaseParse * parse,
+    GstBaseParseFrame * frame);
+static GstCaps *gst_ac4_parse_get_sink_caps (GstBaseParse * parse,
+    GstCaps * filter);
+
+#define gst_ac4_parse_parent_class parent_class
+G_DEFINE_TYPE (GstAc4Parse, gst_ac4_parse, GST_TYPE_BASE_PARSE);
+GST_ELEMENT_REGISTER_DEFINE (ac4parse, "ac4parse",
+    GST_RANK_PRIMARY + 1, GST_TYPE_AC4_PARSE);
+
+static void
+gst_ac4_parse_class_init (GstAc4ParseClass * klass)
+{
+  GObjectClass *object_class = G_OBJECT_CLASS (klass);
+  GstElementClass *element_class = GST_ELEMENT_CLASS (klass);
+  GstBaseParseClass *parse_class = GST_BASE_PARSE_CLASS (klass);
+
+  GST_DEBUG_CATEGORY_INIT (ac4_parse_debug, "ac4parse", 0,
+      "AC4 audio stream parser");
+  GST_DEBUG_OBJECT (klass, "init");
+  object_class->finalize = gst_ac4_parse_finalize;
+
+  gst_element_class_add_static_pad_template (element_class, &sink_template);
+  gst_element_class_add_static_pad_template (element_class, &src_template);
+
+  gst_element_class_set_static_metadata (element_class,
+      "AC4 audio stream parser", "Codec/Parser/Converter/Audio",
+      "AC4 parser", "Tim-Philipp Müller <tim centricular net>");
+
+  parse_class->start = GST_DEBUG_FUNCPTR (gst_ac4_parse_start);
+  parse_class->stop = GST_DEBUG_FUNCPTR (gst_ac4_parse_stop);
+  parse_class->handle_frame = GST_DEBUG_FUNCPTR (gst_ac4_parse_handle_frame);
+  parse_class->pre_push_frame =
+      GST_DEBUG_FUNCPTR (gst_ac4_parse_pre_push_frame);
+  parse_class->get_sink_caps = GST_DEBUG_FUNCPTR (gst_ac4_parse_get_sink_caps);
+}
+
+static void
+gst_ac4_parse_reset (GstAc4Parse * ac4parse)
+{
+  ac4parse->channels = -1;
+  ac4parse->sample_rate = -1;
+  ac4parse->sent_codec_tag = FALSE;
+}
+
+static void
+gst_ac4_parse_init (GstAc4Parse * ac4parse)
+{
+   GST_DEBUG_OBJECT (ac4parse, "init");
+  gst_base_parse_set_min_frame_size (GST_BASE_PARSE (ac4parse), 8);
+  gst_ac4_parse_reset (ac4parse);
+  GST_PAD_SET_ACCEPT_INTERSECT (GST_BASE_PARSE_SINK_PAD (ac4parse));
+  GST_PAD_SET_ACCEPT_TEMPLATE (GST_BASE_PARSE_SINK_PAD (ac4parse));
+}
+
+static void
+gst_ac4_parse_finalize (GObject * object)
+{
+  G_OBJECT_CLASS (parent_class)->finalize (object);
+}
+
+static gboolean
+gst_ac4_parse_start (GstBaseParse * parse)
+{
+  GstAc4Parse *ac4parse = GST_AC4_PARSE (parse);
+
+  GST_DEBUG_OBJECT (parse, "starting");
+
+  gst_ac4_parse_reset (ac4parse);
+
+  return TRUE;
+}
+
+static gboolean
+gst_ac4_parse_stop (GstBaseParse * parse)
+{
+  GST_DEBUG_OBJECT (parse, "stopping");
+
+  return TRUE;
+}
+static int32_t readVariableBits(GstBitReader *bits, guint nbits) {
+    int32_t value = 0;
+    int32_t more_bits = 1;
+
+    while (more_bits) {
+        value += gst_bit_reader_get_bits_uint32_unchecked (bits, nbits);
+        more_bits = gst_bit_reader_get_bits_uint32_unchecked (bits, 1);
+        if (!more_bits)
+            break;
+        value++;
+        value <<= nbits;
+    }
+    return value;
+}
+
+static gboolean
+gst_ac4_parse_frame_header (GstAc4Parse * parse, GstBuffer * buf, gint skip,
+    guint * framesize, guint * rate, guint * chans)
+{
+  GstBitReader bits;
+  guint16 sync;
+  guint8 bsid;
+  GstMapInfo map;
+  gboolean ret = FALSE;
+  static const int kSyncWordAC40 = 0xAC40;
+  static const int kSyncWordAC41 = 0xAC41;
+
+  gst_buffer_map (buf, &map, GST_MAP_READ);
+  gst_bit_reader_init (&bits, map.data, map.size);
+
+  gst_bit_reader_skip_unchecked (&bits, skip * 8);
+
+  sync = gst_bit_reader_get_bits_uint16_unchecked (&bits, 16);
+
+  guint frame_size = 0;
+  guint headerSize = 0;
+  if (G_UNLIKELY (sync != 0xAC40) && G_UNLIKELY (sync != 0xAC41))
+    goto cleanup;
+  headerSize += 2;
+
+  frame_size = gst_bit_reader_get_bits_uint16_unchecked (&bits, 16);
+  headerSize += 2;
+
+  if (frame_size == 0xFFFF) {
+    frame_size = gst_bit_reader_get_bits_uint32_unchecked (&bits, 24);
+    headerSize += 3;
+  }
+  if (frame_size == 0) {
+    goto cleanup;
+  }
+
+  frame_size += headerSize;
+  if (sync == kSyncWordAC41) {
+    frame_size += 2; // crc_word
+  }
+  GST_INFO_OBJECT(parse, "AC4 frameSize = %d", frame_size);
+  *framesize = frame_size;
+  // ETSI TS 103 190-2 V1.1.1 6.2.1.1
+    guint8 bitstreamVersion = gst_bit_reader_get_bits_uint8_unchecked (&bits, 2);
+    if (bitstreamVersion == 3) {
+        bitstreamVersion += readVariableBits(&bits, 2);
+    }
+    gst_bit_reader_skip_unchecked (&bits, 10);
+
+    uint8_t bWaitFrames = gst_bit_reader_get_bits_uint8_unchecked (&bits, 1);
+    if (bWaitFrames) {
+        uint8_t waitFrames = gst_bit_reader_get_bits_uint8_unchecked (&bits, 3);
+        if (waitFrames > 0) {
+            gst_bit_reader_skip_unchecked (&bits, 2);; // br_code;
+        }
+    }
+    guint8 fsIndex = gst_bit_reader_get_bits_uint8_unchecked (&bits, 1);
+    uint32_t samplingRate = fsIndex == 0 ? 44100 : 48000;
+    *rate = samplingRate;
+    *chans = 2;
+    ret = TRUE;
+
+cleanup:
+  gst_buffer_unmap (buf, &map);
+
+  return ret;
+}
+
+static GstFlowReturn
+gst_ac4_parse_handle_frame (GstBaseParse * parse,
+    GstBaseParseFrame * frame, gint * skipsize)
+{
+  GstAc4Parse *ac4parse = GST_AC4_PARSE (parse);
+  GstBuffer *buf = frame->buffer;
+  GstByteReader reader;
+  gint off;
+  guint rate, chans;
+  gboolean update_rate = FALSE;
+  gint frmsiz = 0;
+  GstMapInfo map;
+  gboolean ret = FALSE;
+  GstFlowReturn res = GST_FLOW_OK;
+  gint best_offset = G_MAXINT;
+
+  gst_buffer_map (buf, &map, GST_MAP_READ);
+
+  if (G_UNLIKELY (map.size < 8)) {
+    *skipsize = 1;
+    goto cleanup;
+  }
+  gst_byte_reader_init (&reader, map.data, map.size);
+
+  off = gst_byte_reader_masked_scan_uint32 (&reader, 0xffff0000, 0xAC400000,
+      0, map.size);
+  if (off >= 0 && off < best_offset) {
+    best_offset = off;
+  }
+
+  off = gst_byte_reader_masked_scan_uint32 (&reader, 0xffff0000, 0xAC410000,
+      0, map.size);
+  if (off >= 0 && off < best_offset) {
+    best_offset = off;
+  }
+
+/* for debug
+  GstMapInfo mapinfo;
+  gchar *p_buf = (gchar*) (map.data);
+  gint size = map.size;
+  GST_LOG_OBJECT (parse, "[%x %x %x %x %x %x %x %x],[%x %x %x %x %x %x %x %x] buffet pts:%lld, size:%d, sync offset:%d",
+    p_buf[0],p_buf[1],p_buf[2],p_buf[3],p_buf[4],p_buf[5],p_buf[6],p_buf[7],
+    p_buf[size-8],p_buf[size-7],p_buf[size-6],p_buf[size-5],p_buf[size-4],p_buf[size-3],p_buf[size-2],p_buf[size-1],
+    GST_BUFFER_PTS(buf), map.size, off);
+*/
+
+  /* didn't find anything that looks like a sync word, skip */
+  if (best_offset < 0) {
+    *skipsize = map.size - 2;
+    goto cleanup;
+  }
+
+  /* possible frame header, but not at offset 0? skip bytes before sync */
+  if (best_offset > 0 && best_offset != G_MAXINT) {
+    *skipsize = best_offset;
+    goto cleanup;
+  }
+
+  /* make sure the values in the frame header look sane */
+  if (!gst_ac4_parse_frame_header (ac4parse, buf, 0, &frmsiz, &rate, &chans)) {
+    *skipsize = best_offset + 2;
+    goto cleanup;
+  }
+
+  GST_LOG_OBJECT (parse, "got frame size: %u, rate: %u, chans: %u", frmsiz, rate, chans);
+
+  /* expect to have found a frame here */
+  g_assert (frmsiz);
+  ret = TRUE;
+
+  if (G_UNLIKELY (ac4parse->sample_rate != rate || ac4parse->channels != chans)) {
+    GstCaps *caps = gst_caps_new_simple ("audio/x-ac4-tcl",
+        "framed", G_TYPE_BOOLEAN, TRUE, "rate", G_TYPE_INT, rate,
+        "channels", G_TYPE_INT, chans, NULL, "parsed", G_TYPE_BOOLEAN, TRUE);
+    gst_pad_set_caps (GST_BASE_PARSE_SRC_PAD (parse), caps);
+    gst_caps_unref (caps);
+
+    ac4parse->sample_rate = rate;
+    ac4parse->channels = chans;
+
+    update_rate = TRUE;
+  }
+
+  if (G_UNLIKELY (update_rate))
+    gst_base_parse_set_frame_rate (parse, rate, 1, 2, 2);
+
+cleanup:
+  gst_buffer_unmap (buf, &map);
+
+  if (ret && frmsiz <= map.size) {
+    res = gst_base_parse_finish_frame (parse, frame, frmsiz);
+  }
+
+  return res;
+}
+
+static GstFlowReturn
+gst_ac4_parse_pre_push_frame (GstBaseParse * parse, GstBaseParseFrame * frame)
+{
+  GstAc4Parse *ac4parse = GST_AC4_PARSE (parse);
+
+  if (!ac4parse->sent_codec_tag) {
+    GstTagList *taglist;
+    GstCaps *caps;
+
+    /* codec tag */
+    caps = gst_pad_get_current_caps (GST_BASE_PARSE_SRC_PAD (parse));
+    if (G_UNLIKELY (caps == NULL)) {
+      if (GST_PAD_IS_FLUSHING (GST_BASE_PARSE_SRC_PAD (parse))) {
+        GST_INFO_OBJECT (parse, "Src pad is flushing");
+        return GST_FLOW_FLUSHING;
+      } else {
+        GST_INFO_OBJECT (parse, "Src pad is not negotiated!");
+        return GST_FLOW_NOT_NEGOTIATED;
+      }
+    }
+
+    taglist = gst_tag_list_new_empty ();
+    gst_pb_utils_add_codec_description_to_tag_list (taglist,
+        GST_TAG_AUDIO_CODEC, caps);
+    gst_caps_unref (caps);
+
+    gst_base_parse_merge_tags (parse, taglist, GST_TAG_MERGE_REPLACE);
+    gst_tag_list_unref (taglist);
+
+    /* also signals the end of first-frame processing */
+    ac4parse->sent_codec_tag = TRUE;
+  }
+
+  frame->flags |= GST_BASE_PARSE_FRAME_FLAG_CLIP;
+
+  return GST_FLOW_OK;
+}
+
+
+static void
+remove_fields (GstCaps * caps)
+{
+  guint i, n;
+
+  n = gst_caps_get_size (caps);
+  for (i = 0; i < n; i++) {
+    GstStructure *s = gst_caps_get_structure (caps, i);
+
+    gst_structure_remove_field (s, "framed");
+    gst_structure_remove_field (s, "alignment");
+  }
+}
+
+static GstCaps *
+gst_ac4_parse_get_sink_caps (GstBaseParse * parse, GstCaps * filter)
+{
+  GstCaps *peercaps, *templ;
+  GstCaps *res;
+
+  templ = gst_pad_get_pad_template_caps (GST_BASE_PARSE_SINK_PAD (parse));
+  if (filter) {
+    GstCaps *fcopy = gst_caps_copy (filter);
+    /* Remove the fields we convert */
+    remove_fields (fcopy);
+    peercaps = gst_pad_peer_query_caps (GST_BASE_PARSE_SRC_PAD (parse), fcopy);
+    gst_caps_unref (fcopy);
+  } else
+    peercaps = gst_pad_peer_query_caps (GST_BASE_PARSE_SRC_PAD (parse), NULL);
+
+  if (peercaps) {
+    /* Remove the framed field */
+    peercaps = gst_caps_make_writable (peercaps);
+    remove_fields (peercaps);
+
+    res = gst_caps_intersect_full (peercaps, templ, GST_CAPS_INTERSECT_FIRST);
+    gst_caps_unref (peercaps);
+    gst_caps_unref (templ);
+  } else {
+    res = templ;
+  }
+
+  if (filter) {
+    GstCaps *intersection;
+
+    intersection =
+        gst_caps_intersect_full (filter, res, GST_CAPS_INTERSECT_FIRST);
+    gst_caps_unref (res);
+    res = intersection;
+  }
+
+  return res;
+}
+
diff --git a/subprojects/gst-plugins-good/gst/audioparsers/gstac4parse.h b/subprojects/gst-plugins-good/gst/audioparsers/gstac4parse.h
new file mode 100755
index 0000000000..9b9b264256
--- /dev/null
+++ b/subprojects/gst-plugins-good/gst/audioparsers/gstac4parse.h
@@ -0,0 +1,66 @@
+/********************************************************************************
+** Copyright (C), 2014-2021, TCL TV Comm Corp., Ltd
+** VENDOR_EDIT, All rights reserved.
+**
+** File: - gstac4parse.h
+** Description:
+**    define parse ac4 struct
+**
+** ------------------------------- Revision History: ---------------------------
+** <author>            <date>       <version>      <desc>
+** -----------------------------------------------------------------------------
+
+*******************************************************************************/
+
+
+#ifndef __GST_AC4_PARSE_H__
+#define __GST_AC4_PARSE_H__
+
+#include <gst/gst.h>
+#include <gst/base/gstbaseparse.h>
+
+G_BEGIN_DECLS
+
+#define GST_TYPE_AC4_PARSE \
+  (gst_ac4_parse_get_type())
+#define GST_AC4_PARSE(obj) \
+  (G_TYPE_CHECK_INSTANCE_CAST((obj), GST_TYPE_AC4_PARSE, GstAc4Parse))
+#define GST_AC4_PARSE_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_CAST((klass), GST_TYPE_AC4_PARSE, GstAc4ParseClass))
+#define GST_IS_AC4_PARSE(obj) \
+  (G_TYPE_CHECK_INSTANCE_TYPE((obj), GST_TYPE_AC4_PARSE))
+#define GST_IS_AC4_PARSE_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_TYPE((klass), GST_TYPE_AC4_PARSE))
+
+typedef struct _GstAc4Parse GstAc4Parse;
+typedef struct _GstAc4ParseClass GstAc4ParseClass;
+
+
+/**
+ * GstAc4Parse:
+ *
+ * The opaque GstAc4Parse object
+ */
+struct _GstAc4Parse {
+  GstBaseParse baseparse;
+  /*< private >*/
+  gint                  sample_rate;
+  gint                  channels;
+  gboolean              sent_codec_tag;
+};
+
+/**
+ * GstAc4ParseClass:
+ * @parent_class: Element parent class.
+ *
+ * The opaque GstAc4ParseClass data structure.
+ */
+struct _GstAc4ParseClass {
+  GstBaseParseClass baseparse_class;
+};
+
+GType gst_ac4_parse_get_type (void);
+
+G_END_DECLS
+
+#endif /* __GST_AC4_PARSE_H__ */
diff --git a/subprojects/gst-plugins-good/gst/audioparsers/gstaudioparserselements.h b/subprojects/gst-plugins-good/gst/audioparsers/gstaudioparserselements.h
old mode 100644
new mode 100755
index 2cf1369739..6c22a34b8a
--- a/subprojects/gst-plugins-good/gst/audioparsers/gstaudioparserselements.h
+++ b/subprojects/gst-plugins-good/gst/audioparsers/gstaudioparserselements.h
@@ -34,6 +34,10 @@ GST_ELEMENT_REGISTER_DECLARE (mpegaudioparse);
 GST_ELEMENT_REGISTER_DECLARE (sbcparse);
 GST_ELEMENT_REGISTER_DECLARE (wavpackparse);
 
+#ifdef TCL_PATCH
+GST_ELEMENT_REGISTER_DECLARE (ac4parse);
+#endif
+
 G_END_DECLS
 
 #endif /* __GST_AUDIOPARSERS_ELEMENTS_H__ */
diff --git a/subprojects/gst-plugins-good/gst/audioparsers/gstdcaparse.c b/subprojects/gst-plugins-good/gst/audioparsers/gstdcaparse.c
index e9c870250b..e92037c7eb 100644
--- a/subprojects/gst-plugins-good/gst/audioparsers/gstdcaparse.c
+++ b/subprojects/gst-plugins-good/gst/audioparsers/gstdcaparse.c
@@ -263,6 +263,99 @@ gst_dca_parse_parse_header (GstDcaParse * dcaparse,
   return TRUE;
 }
 
+#ifdef TCL_PATCH
+static gboolean
+gst_dca_parse_parse_lbr_header (GstDcaParse * dcaparse,
+    const GstBitReader * reader, guint * frame_size,
+    guint * sample_rate, guint * channels, guint * depth,
+    gint * endianness, guint * num_blocks, guint * samples_per_block,
+    gboolean * terminator)
+{
+  GstBitReader r = *reader;
+  guint32 marker;
+  guint8 SubIdx = 0;
+  guint8 wide_hdr = 0;
+  guint32 header_size;
+  guint32 exss_size_nbits = 0;
+  guint32 exss_size;
+  guint8 bStaticFieldsPresent = 0;
+  guint32 RefClockPeriod = 0;
+  gint32 ExSSFrameDurationCode = 0;
+  gint32 ExSSFrameDuration = 0;
+  guint8 NumAudio = 1;
+  guint8 NumAssets = 1;
+  guint8 bMixMetaDataEnbl = 0;
+  guint8 nuBits4MixOutMask = 0;
+  guint8 nuNumMixOutConfigs = 0;
+  static const int lbr_sample_rates[3] = {32000, 44100, 48000};
+
+  marker = gst_bit_reader_get_bits_uint32_unchecked(&r, 32);
+  gst_bit_reader_skip(&r, 8);                 /* Unknown */
+  SubIdx = gst_bit_reader_get_bits_uint8_unchecked(&r, 2);               /* Substream Index */
+  wide_hdr = gst_bit_reader_get_bits_uint8_unchecked(&r, 1);             /* Blown Up Header, wide_hdr, Flag indicating short or long header size*/
+  header_size = gst_bit_reader_get_bits_uint16_unchecked(&r, 8 + 4 * wide_hdr) + 1; /* Header Size */
+  exss_size_nbits = 16 + 4 * wide_hdr;
+  exss_size = gst_bit_reader_get_bits_uint32_unchecked(&r, exss_size_nbits) + 1; /* Number of bytes of extension substream, HD or subframe size*/
+  *frame_size = exss_size;
+
+  bStaticFieldsPresent = gst_bit_reader_get_bits_uint8_unchecked(&r, 1);          /* Static fields present */
+  RefClockPeriod = 0;
+  if (bStaticFieldsPresent) {
+    RefClockPeriod = gst_bit_reader_get_bits_uint8_unchecked(&r, 2);     /* 2b: Reference clock code,3b: ExSS frame duration code */
+    if (RefClockPeriod > 2) {
+      GST_ERROR_OBJECT (dcaparse, "RefClockPeriod > 2, RefClockPeriod = %u", RefClockPeriod);
+      return FALSE;
+    }
+    RefClockPeriod = lbr_sample_rates[RefClockPeriod];
+    ExSSFrameDurationCode = gst_bit_reader_get_bits_uint8_unchecked(&r,3) + 1;
+    ExSSFrameDuration = (float) (ExSSFrameDurationCode * 512 * 1000) / RefClockPeriod;
+    *sample_rate = RefClockPeriod;
+    *num_blocks = ExSSFrameDurationCode;
+    *samples_per_block = 512;
+    if (gst_bit_reader_get_bits_uint8_unchecked(&r, 1)) {
+      gst_bit_reader_skip(&r, 36);
+    }
+    NumAudio = gst_bit_reader_get_bits_uint8_unchecked(&r, 3) + 1;
+    NumAssets = gst_bit_reader_get_bits_uint8_unchecked(&r, 3) + 1;     /* Number of audio assets in extension substream*/
+    gst_bit_reader_skip(&r, NumAudio * (SubIdx + 1));
+    gst_bit_reader_skip(&r, NumAudio * (SubIdx + 1) * 8);
+    bMixMetaDataEnbl = gst_bit_reader_get_bits_uint8_unchecked(&r, 1);/* Mix Metadata Flag */
+    if(bMixMetaDataEnbl)
+    {
+        gst_bit_reader_skip(&r, 2);         /* nuMixMetadataAdjLevel, Mix Metadata Adjustment Level,  */
+        nuBits4MixOutMask = ( gst_bit_reader_get_bits_uint8_unchecked(&r, 2) + 1 ) << 2;
+        nuNumMixOutConfigs = gst_bit_reader_get_bits_uint8_unchecked(&r, 2) + 1;
+
+        /* Output Mixing Configuration Loop  */
+        gst_bit_reader_skip(&r, nuNumMixOutConfigs * nuBits4MixOutMask);
+    }
+  }
+  gst_bit_reader_skip(&r, NumAssets * exss_size_nbits);
+  gst_bit_reader_skip(&r, 12);
+  if (gst_bit_reader_get_bits_uint8_unchecked(&r, 1)) {               /* Asset type descriptor present */
+    gst_bit_reader_skip(&r, 4);            /* Asset type descriptor */
+  }
+  if (gst_bit_reader_get_bits_uint8_unchecked(&r, 1)) {               /* Language descriptor present */
+    gst_bit_reader_skip(&r, 24);           /* Language descriptor */
+  }
+  if (gst_bit_reader_get_bits_uint8_unchecked(&r, 1)) {               /* Info text present */
+    guint16 bytes = gst_bit_reader_get_bits_uint16_unchecked(&r, 10) + 1;      /* Info text size */
+    gst_bit_reader_skip(&r, bytes * 8);
+  }
+  gst_bit_reader_skip(&r, 9);
+  *channels = gst_bit_reader_get_bits_uint16_unchecked(&r, 8) + 1;
+  *terminator = FALSE;
+  *depth = 16;  // Typically 16-bit depth for DTS LBR
+  *endianness = marker == 0x64582025 ? G_BIG_ENDIAN : G_LITTLE_ENDIAN;
+
+  GST_TRACE_OBJECT (dcaparse, "frame size %u, channels %u, rate %u, "
+      "num_blocks %u, samples_per_block %u, depth %u", *frame_size, *channels,
+      *sample_rate, *num_blocks, *samples_per_block, *depth);
+
+  return TRUE;
+}
+#endif
+
 static gint
 gst_dca_parse_find_sync (GstDcaParse * dcaparse, GstByteReader * reader,
     gsize bufsize, guint32 * sync)
@@ -307,7 +400,23 @@ gst_dca_parse_find_sync (GstDcaParse * dcaparse, GstByteReader * reader,
     best_offset = off;
     best_sync = 0x1fffe800;
   }
+#ifdef TCL_PATCH
+  if (best_sync == 0) {
+    off = gst_byte_reader_masked_scan_uint32 (reader, 0xffffffff, 0x64582025,
+        0, bufsize);
+    if (off >= 0 && off < best_offset) {
+      best_offset = off;
+      best_sync = 0x64582025;
+    }
 
+    off = gst_byte_reader_masked_scan_uint32 (reader, 0xffffffff, 0x58642520,
+        0, bufsize);
+    if (off >= 0 && off < best_offset) {
+      best_offset = off;
+      best_sync = 0x58642520;
+    }
+  }
+#endif
   if (best_offset == G_MAXUINT)
     return -1;
 
@@ -367,13 +476,30 @@ gst_dca_parse_handle_frame (GstBaseParse * parse,
     *skipsize = off;
     goto cleanup;
   }
-
-  /* make sure the values in the frame header look sane */
+#ifdef TCL_PATCH
+  GstBitReader br;
+  if (sync == 0x64582025 || sync == 0x58642520) {
+    gst_bit_reader_init (&br, map.data, map.size);
+    if (!gst_dca_parse_parse_lbr_header (dcaparse, &br, &size, &rate, &chans, &depth,
+            &endianness, &num_blocks, &samples_per_block, &terminator)) {
+      *skipsize = 4;
+      goto cleanup;
+    }
+  } else {
+    /* make sure the values in the frame header look sane */
+    if (!gst_dca_parse_parse_header (dcaparse, &r, &size, &rate, &chans, &depth,
+            &endianness, &num_blocks, &samples_per_block, &terminator)) {
+      *skipsize = 4;
+      goto cleanup;
+    }
+  }
+#else
   if (!gst_dca_parse_parse_header (dcaparse, &r, &size, &rate, &chans, &depth,
           &endianness, &num_blocks, &samples_per_block, &terminator)) {
     *skipsize = 4;
     goto cleanup;
   }
+#endif
 
   GST_LOG_OBJECT (parse, "got frame, sync %08x, size %u, rate %d, channels %d",
       sync, size, rate, chans);
@@ -430,12 +556,22 @@ gst_dca_parse_handle_frame (GstBaseParse * parse,
           || (size != dcaparse->frame_size))) {
     GstCaps *caps;
 
+#ifdef TCL_PATCH
+    caps = gst_caps_new_simple ("audio/x-dts",
+        "framed", G_TYPE_BOOLEAN, TRUE,
+        "rate", G_TYPE_INT, rate, "channels", G_TYPE_INT, chans,
+        "endianness", G_TYPE_INT, endianness, "depth", G_TYPE_INT, depth,
+        "block-size", G_TYPE_INT, block_size, "frame-size", G_TYPE_INT, size,
+        "parsed", G_TYPE_BOOLEAN, TRUE,
+        NULL);
+#else
     caps = gst_caps_new_simple ("audio/x-dts",
         "framed", G_TYPE_BOOLEAN, TRUE,
         "rate", G_TYPE_INT, rate, "channels", G_TYPE_INT, chans,
         "endianness", G_TYPE_INT, endianness, "depth", G_TYPE_INT, depth,
         "block-size", G_TYPE_INT, block_size, "frame-size", G_TYPE_INT, size,
         NULL);
+#endif
     gst_pad_set_caps (GST_BASE_PARSE_SRC_PAD (parse), caps);
     gst_caps_unref (caps);
 
@@ -456,8 +592,13 @@ cleanup:
     if (map.size >= size + 9) {
       const guint8 *next = map.data + size;
       /* Check for DTS_SYNCWORD_SUBSTREAM */
+#ifdef TCL_PATCH
+      if (dcaparse->last_sync != 0x64582025 && next[0] == 0x64 && next[1] == 0x58 && next[2] == 0x20
+          && next[3] == 0x25) {
+#else
       if (next[0] == 0x64 && next[1] == 0x58 && next[2] == 0x20
           && next[3] == 0x25) {
+#endif
         /* 7.4.1 Extension Substream Header */
         GstBitReader reader;
         gst_bit_reader_init (&reader, next + 4, 5);
diff --git a/subprojects/gst-plugins-good/gst/audioparsers/meson.build b/subprojects/gst-plugins-good/gst/audioparsers/meson.build
old mode 100644
new mode 100755
index 2bd5d245c3..531d6a8f51
--- a/subprojects/gst-plugins-good/gst/audioparsers/meson.build
+++ b/subprojects/gst-plugins-good/gst/audioparsers/meson.build
@@ -7,6 +7,7 @@ audioparsers_src = [
   'gstmpegaudioparse.c',
   'gstsbcparse.c',
   'gstwavpackparse.c',
+  'gstac4parse.c',
   'plugin.c',
 ]
 
diff --git a/subprojects/gst-plugins-good/gst/audioparsers/plugin.c b/subprojects/gst-plugins-good/gst/audioparsers/plugin.c
old mode 100644
new mode 100755
index 0126af6fe3..ff383738da
--- a/subprojects/gst-plugins-good/gst/audioparsers/plugin.c
+++ b/subprojects/gst-plugins-good/gst/audioparsers/plugin.c
@@ -36,6 +36,9 @@ plugin_init (GstPlugin * plugin)
   ret |= GST_ELEMENT_REGISTER (mpegaudioparse, plugin);
   ret |= GST_ELEMENT_REGISTER (sbcparse, plugin);
   ret |= GST_ELEMENT_REGISTER (wavpackparse, plugin);
+#ifdef TCL_PATCH
+  ret |= GST_ELEMENT_REGISTER (ac4parse, plugin);
+#endif
 
   return ret;
 }
diff --git a/subprojects/gst-plugins-good/gst/autodetect/gstautodetectplugin.c b/subprojects/gst-plugins-good/gst/autodetect/gstautodetectplugin.c
index c925e5a289..cc3ab5bd0a 100644
--- a/subprojects/gst-plugins-good/gst/autodetect/gstautodetectplugin.c
+++ b/subprojects/gst-plugins-good/gst/autodetect/gstautodetectplugin.c
@@ -31,9 +31,13 @@ plugin_init (GstPlugin * plugin)
   gboolean ret = FALSE;
 
   ret |= GST_ELEMENT_REGISTER (autovideosink, plugin);
+#ifndef TCL_PATCH
   ret |= GST_ELEMENT_REGISTER (autovideosrc, plugin);
+#endif
   ret |= GST_ELEMENT_REGISTER (autoaudiosink, plugin);
+#ifndef TCL_PATCH
   ret |= GST_ELEMENT_REGISTER (autoaudiosrc, plugin);
+#endif
 
   return ret;
 }
diff --git a/subprojects/gst-plugins-good/gst/avi/gstavi.c b/subprojects/gst-plugins-good/gst/avi/gstavi.c
index 012f5c47bc..90687e59c4 100644
--- a/subprojects/gst-plugins-good/gst/avi/gstavi.c
+++ b/subprojects/gst-plugins-good/gst/avi/gstavi.c
@@ -31,7 +31,9 @@ plugin_init (GstPlugin * plugin)
   gboolean ret = FALSE;
 
   ret |= GST_ELEMENT_REGISTER (avidemux, plugin);
+#ifndef TCL_PATCH
   ret |= GST_ELEMENT_REGISTER (avimux, plugin);
+#endif
   ret |= GST_ELEMENT_REGISTER (avisubtitle, plugin);
 
   return ret;
diff --git a/subprojects/gst-plugins-good/gst/avi/gstavidemux.c b/subprojects/gst-plugins-good/gst/avi/gstavidemux.c
index b4616a684c..ac217ebfb4 100644
--- a/subprojects/gst-plugins-good/gst/avi/gstavidemux.c
+++ b/subprojects/gst-plugins-good/gst/avi/gstavidemux.c
@@ -53,6 +53,9 @@
 #include <gst/gst-i18n-plugin.h>
 #include <gst/base/gstadapter.h>
 #include <gst/tag/tag.h>
+#ifdef TCL_PATCH
+#include <sys/system_properties.h>
+#endif
 
 #define DIV_ROUND_UP(s,v) (((s) + ((v)-1)) / (v))
 
@@ -61,6 +64,15 @@
 #define ENTRY_SET_KEYFRAME(e) ((e)->flags = GST_AVI_KEYFRAME)
 #define ENTRY_UNSET_KEYFRAME(e) ((e)->flags = 0)
 
+#ifdef TCL_PATCH
+#define ABSDIFF(a,b) (((a) > (b)) ? ((a) - (b)) : ((b) - (a)))
+
+enum
+{
+  PROP_0,
+  PROP_SEEKABLE,
+};
+#endif
 
 GST_DEBUG_CATEGORY_STATIC (avidemux_debug);
 #define GST_CAT_DEFAULT avidemux_debug
@@ -125,6 +137,13 @@ static void gst_avi_demux_get_buffer_info (GstAviDemux * avi,
 
 static void gst_avi_demux_parse_idit (GstAviDemux * avi, GstBuffer * buf);
 static void gst_avi_demux_parse_strd (GstAviDemux * avi, GstBuffer * buf);
+#ifdef TCL_PATCH
+static void gst_avi_demux_demux_remove_pad(GstElement *element, GstPad *pad);
+static void gst_avi_demux_set_property (GObject * object,
+    guint prop_id, const GValue * value, GParamSpec * pspec);
+static void gst_avi_demux_get_property (GObject * object,
+    guint prop_id, GValue * value, GParamSpec * pspec);
+#endif
 
 static void parse_tag_value (GstAviDemux * avi, GstTagList * taglist,
     const gchar * type, guint8 * ptr, guint tsize);
@@ -149,6 +168,10 @@ gst_avi_demux_class_init (GstAviDemuxClass * klass)
 
   gobject_class->finalize = gst_avi_demux_finalize;
 
+#ifdef TCL_PATCH
+  gobject_class->get_property = gst_avi_demux_get_property;
+  gobject_class->set_property = gst_avi_demux_set_property;
+#endif
   gstelement_class->change_state =
       GST_DEBUG_FUNCPTR (gst_avi_demux_change_state);
 #if 0
@@ -156,6 +179,16 @@ gst_avi_demux_class_init (GstAviDemuxClass * klass)
   gstelement_class->get_index = GST_DEBUG_FUNCPTR (gst_avi_demux_get_index);
 #endif
 
+#ifdef TCL_PATCH
+  //  gstelement_class->demux_remove_pad = GST_DEBUG_FUNCPTR (gst_avi_demux_demux_remove_pad);
+
+    g_object_class_install_property (gobject_class, PROP_SEEKABLE,
+        g_param_spec_boolean ("is-seekable",
+            "seekable by keyframe",
+            "when there is no keyframe, it is not seekable",
+            FALSE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+#endif
+
   audcaps = gst_riff_create_audio_template_caps ();
   gst_caps_append (audcaps, gst_caps_new_empty_simple ("audio/x-avi-unknown"));
   audiosrctempl = gst_pad_template_new ("audio_%u",
@@ -209,6 +242,14 @@ gst_avi_demux_init (GstAviDemux * avi)
   avi->adapter = gst_adapter_new ();
   avi->flowcombiner = gst_flow_combiner_new ();
 
+#ifdef TCL_PATCH
+  avi->video_hdr_duration = GST_CLOCK_TIME_NONE;
+  avi->audio_hdr_duration = GST_CLOCK_TIME_NONE;
+  avi->is_seekable = TRUE;
+  memset(avi->platform_val, 0, 128);
+  __system_property_get("ro.hardware.version_id", avi->platform_val);
+  GST_INFO ("ro.hardware.version_id = %s", avi->platform_val);
+#endif
   gst_avi_demux_reset (avi);
 
   GST_OBJECT_FLAG_SET (avi, GST_ELEMENT_FLAG_INDEXABLE);
@@ -535,7 +576,17 @@ gst_avi_demux_handle_src_query (GstPad * pad, GstObject * parent,
       if ((duration = stream->duration) == -1)
         if ((duration = stream->hdr_duration) == -1)
           duration = avi->duration;
-
+#ifdef TCL_PATCH
+      if (avi->streaming && avi->duration != -1 && avi->video_hdr_duration != -1 &&
+        avi->audio_hdr_duration != -1 && ABSDIFF(avi->video_hdr_duration, avi->audio_hdr_duration) > 60 * 60 * GST_SECOND) {
+          duration = avi->duration;
+          avi->is_seekable = FALSE;
+          gst_element_post_message (GST_ELEMENT_CAST (avi),
+          gst_message_new_element (GST_OBJECT_CAST (avi),
+          gst_structure_new ("is-seekable", "is_seekable", G_TYPE_BOOLEAN, avi->is_seekable, NULL)));
+          GST_ERROR("avi->seekable = FALSE");
+      }
+#endif
       gst_query_parse_duration (query, &fmt, NULL);
 
       switch (fmt) {
@@ -1360,8 +1411,18 @@ gst_avi_demux_add_index (GstAviDemux * avi, GstAviStream * stream,
       entry->total = stream->total_bytes;
     }
     blockalign = stream->strf.auds->blockalign;
+#ifdef TCL_PATCH
+    if (blockalign > 0) {
+      guint32 blocks = DIV_ROUND_UP (entry->size, blockalign);
+      if (stream->strf.auds->format == GST_RIFF_WAVE_FORMAT_VORBIS) {
+        stream->total_blocks += blocks > 0 ? blocks : 1;
+      } else
+        stream->total_blocks += blocks;
+    }
+#else
     if (blockalign > 0)
       stream->total_blocks += DIV_ROUND_UP (entry->size, blockalign);
+#endif
     else
       stream->total_blocks++;
   } else {
@@ -1482,7 +1543,6 @@ gst_avi_demux_do_index_stats (GstAviDemux * avi)
         stream->n_keyframes, (guint) sizeof (GstAviIndexEntry),
         (guint) (stream->idx_n * sizeof (GstAviIndexEntry)),
         (guint) (stream->idx_max * sizeof (GstAviIndexEntry)));
-
     /* knowing all that we do, that also includes avg bitrate */
     if (!stream->taglist) {
       stream->taglist = gst_tag_list_new_empty ();
@@ -2059,6 +2119,9 @@ gst_avi_demux_parse_stream (GstAviDemux * avi, GstBuffer * buf)
   stream->idx_duration = GST_CLOCK_TIME_NONE;
   stream->hdr_duration = GST_CLOCK_TIME_NONE;
   stream->duration = GST_CLOCK_TIME_NONE;
+#ifdef TCL_PATCH
+  stream->droped_flag  = FALSE;
+#endif
 
   while (gst_riff_parse_chunk (element, buf, &offset, &tag, &sub)) {
     /* sub can be NULL if the chunk is empty */
@@ -2104,6 +2167,14 @@ gst_avi_demux_parse_stream (GstAviDemux * avi, GstBuffer * buf)
         /* determine duration as indicated by header */
         stream->hdr_duration = gst_util_uint64_scale ((guint64) strh->length *
             strh->scale, GST_SECOND, (guint64) strh->rate);
+#ifdef TCL_PATCH
+        if (stream->strh->type == GST_RIFF_FCC_vids) {
+          avi->video_hdr_duration = stream->hdr_duration;
+        }
+        if (stream->strh->type == GST_RIFF_FCC_auds) {
+          avi->audio_hdr_duration = stream->hdr_duration;
+        }
+#endif
         GST_INFO ("Stream duration according to header: %" GST_TIME_FORMAT,
             GST_TIME_ARGS (stream->hdr_duration));
         if (stream->hdr_duration == 0)
@@ -2139,9 +2210,15 @@ gst_avi_demux_parse_stream (GstAviDemux * avi, GstBuffer * buf)
             sub = NULL;
             if (!res)
               break;
+#ifdef TCL_PATCH
+            stream->is_vbr = (stream->strh->samplesize == 0)
+                && ((stream->strh->scale > 1) || ((stream->strh->scale >= 1) && (stream->strh->rate > 1) && (stream->strf.auds->format == GST_RIFF_WAVE_FORMAT_VORBIS)))
+                && stream->strf.auds->blockalign != 1;
+#else
             stream->is_vbr = (stream->strh->samplesize == 0)
                 && stream->strh->scale > 1
                 && stream->strf.auds->blockalign != 1;
+#endif
             GST_DEBUG_OBJECT (element, "marking audio as VBR:%d, res %d",
                 stream->is_vbr, res);
             /* we need these or we have no way to come up with timestamps */
@@ -2154,16 +2231,29 @@ gst_avi_demux_parse_stream (GstAviDemux * avi, GstBuffer * buf)
             }
             /* some more sanity checks */
             if (stream->is_vbr) {
-              if (stream->strf.auds->blockalign <= 4) {
-                /* that would mean (too) many frames per chunk,
-                 * so not likely set as expected */
-                GST_DEBUG_OBJECT (element,
-                    "suspicious blockalign %d for VBR audio; "
-                    "overriding to 1 frame per chunk",
-                    stream->strf.auds->blockalign);
-                /* this should top any likely value */
-                stream->strf.auds->blockalign = (1 << 12);
-              }
+#ifdef TCL_PATCH
+                if (stream->strf.auds->blockalign <= 4 || (stream->strf.auds->format == GST_RIFF_WAVE_FORMAT_EXTENSIBLE && stream->strf.auds->blockalign <= 12)) {
+                    /* that would mean (too) many frames per chunk,
+                    * so not likely set as expected */
+                    GST_DEBUG_OBJECT (element,
+                        "suspicious blockalign %d for VBR audio; "
+                        "overriding to 1 frame per chunk",
+                        stream->strf.auds->blockalign);
+                    /* this should top any likely value */
+                    stream->strf.auds->blockalign = (1 << 12);
+                }
+#else
+                if (stream->strf.auds->blockalign <= 4) {
+                    /* that would mean (too) many frames per chunk,
+                    * so not likely set as expected */
+                    GST_DEBUG_OBJECT (element,
+                        "suspicious blockalign %d for VBR audio; "
+                        "overriding to 1 frame per chunk",
+                        stream->strf.auds->blockalign);
+                    /* this should top any likely value */
+                    stream->strf.auds->blockalign = (1 << 12);
+                }
+#endif
             }
             break;
           case GST_RIFF_FCC_iavs:
@@ -2348,9 +2438,45 @@ gst_avi_demux_parse_stream (GstAviDemux * avi, GstBuffer * buf)
       /* FIXME: Do something with the channel reorder map */
       padname = g_strdup_printf ("audio_%u", avi->num_a_streams);
       templ = gst_element_class_get_pad_template (klass, "audio_%u");
+
+#ifdef TCL_PATCH
+      //the WMA7/8/10 need extra size +18, WMA10 5.1CH need to modify in riff-media.c
+      const guint8 *config_data = (const guint8 *) stream->strf.auds;
+      GstBuffer *extra = NULL;
+      gsize size = gst_buffer_get_size (stream->extradata);
+      guint16 datalen = size + 18;
+      GST_DEBUG_OBJECT (avi, "datalen is %d", datalen);
+      if (stream->strf.auds->format == 0x160 || stream->strf.auds->format == 0x161 || stream->strf.auds->format == 0x162) {
+        extra = gst_buffer_new_and_alloc (datalen);
+        gst_buffer_fill (extra, 0, config_data, datalen);
+        caps = gst_riff_create_audio_caps (stream->strf.auds->format,
+            stream->strh, stream->strf.auds, extra,
+            stream->initdata, &codec_name, NULL);
+      } else if (stream->strf.auds->format == 0x11 && !strncmp(avi->platform_val, "MT9655", 6)) {
+        extra = gst_buffer_new_and_alloc (size);
+        gst_buffer_fill (extra, 0, config_data + 12, size);
+        caps = gst_riff_create_audio_caps (stream->strf.auds->format,
+            stream->strh, stream->strf.auds, extra,
+            stream->initdata, &codec_name, NULL);
+      } else if (stream->strf.auds->format == 0x0002 && !strncmp(avi->platform_val, "MT9655", 6)) {
+        guint codec_data_size = 2;
+        extra = gst_buffer_new_and_alloc (codec_data_size);
+        gst_buffer_fill (extra, 0, config_data + 12, codec_data_size);
+        caps = gst_riff_create_audio_caps (stream->strf.auds->format,
+            stream->strh, stream->strf.auds, extra,
+            stream->initdata, &codec_name, NULL);
+      }  else {
+        caps = gst_riff_create_audio_caps (stream->strf.auds->format,
+            stream->strh, stream->strf.auds, stream->extradata,
+            stream->initdata, &codec_name, NULL);
+      }
+      if (extra)
+        gst_buffer_unref (extra);
+#else
       caps = gst_riff_create_audio_caps (stream->strf.auds->format,
           stream->strh, stream->strf.auds, stream->extradata,
           stream->initdata, &codec_name, NULL);
+#endif
       if (!caps) {
         caps = gst_caps_new_simple ("audio/x-avi-unknown", "codec_id",
             G_TYPE_INT, stream->strf.auds->format, NULL);
@@ -3156,9 +3282,13 @@ gst_avi_demux_stream_scan (GstAviDemux * avi)
 
     /* start reading data buffers to find the id and offset */
     res = gst_avi_demux_next_data_buffer (avi, &pos, &tag, &size);
+#if TCL_PATCH
+    if (G_UNLIKELY (res != GST_FLOW_OK || size <= 0))
+      break;
+#else
     if (G_UNLIKELY (res != GST_FLOW_OK))
       break;
-
+#endif
     /* get stream */
     stream = gst_avi_demux_stream_for_id (avi, tag);
     if (G_UNLIKELY (!stream))
@@ -4530,6 +4660,19 @@ gst_avi_demux_do_seek (GstAviDemux * avi, GstSegment * segment,
   /* move the main stream to this position */
   gst_avi_demux_move_stream (avi, stream, segment, index);
 
+#ifdef TCL_PATCH
+  seek_time = stream->current_timestamp;
+  GST_DEBUG_OBJECT (avi, "keyframe adjusted to %" GST_TIME_FORMAT,
+    GST_TIME_ARGS (seek_time));
+  /* the seek time is always the position ... */
+  segment->position = seek_time;
+  /* ... and start and stream time when going forwards,
+   * otherwise only stop time */
+  if (segment->rate > 0.0)
+    segment->start = segment->time = seek_time;
+  else
+    segment->stop = seek_time;
+#else
   if (keyframe) {
     /* when seeking to a keyframe, we update the result seek time
      * to the time of the keyframe. */
@@ -4545,6 +4688,7 @@ gst_avi_demux_do_seek (GstAviDemux * avi, GstSegment * segment,
     else
       segment->stop = seek_time;
   }
+#endif
 
   /* now set DISCONT and align the other streams */
   for (i = 0; i < avi->num_streams; i++) {
@@ -4901,6 +5045,12 @@ static gboolean
 gst_avi_demux_handle_seek_push (GstAviDemux * avi, GstPad * pad,
     GstEvent * event)
 {
+#ifdef TCL_PATCH
+  if (!avi->is_seekable) {
+    GST_ERROR("!avi->is_seekable gst_avi_demux_handle_seek_push ");
+    return FALSE;
+  }
+#endif
   /* check for having parsed index already */
   if (!avi->have_index) {
     guint64 offset = 0;
@@ -4959,9 +5109,9 @@ swap_line (guint8 * d1, guint8 * d2, guint8 * tmp, gint bytes)
 }
 
 
-#define gst_avi_demux_is_uncompressed(fourcc)		\
-  (fourcc == GST_RIFF_DIB ||				\
-   fourcc == GST_RIFF_rgb ||				\
+#define gst_avi_demux_is_uncompressed(fourcc)       \
+  (fourcc == GST_RIFF_DIB ||                \
+   fourcc == GST_RIFF_rgb ||                \
    fourcc == GST_RIFF_RGB || fourcc == GST_RIFF_RAW)
 
 /*
@@ -5071,6 +5221,12 @@ static GstFlowReturn
 gst_avi_demux_combine_flows (GstAviDemux * avi, GstAviStream * stream,
     GstFlowReturn ret)
 {
+#if TCL_PATCH
+#if 0
+  if(TRUE == stream->droped_flag)
+    return  GST_FLOW_OK;
+#endif
+#endif
   GST_LOG_OBJECT (avi, "Stream %s:%s flow return: %s",
       GST_DEBUG_PAD_NAME (stream->pad), gst_flow_get_name (ret));
   ret = gst_flow_combiner_update_pad_flow (avi->flowcombiner, stream->pad, ret);
@@ -5321,7 +5477,11 @@ gst_avi_demux_loop_data (GstAviDemux * avi)
       GST_BUFFER_PTS (buf) = timestamp;
     } else {
       GST_BUFFER_FLAG_SET (buf, GST_BUFFER_FLAG_DELTA_UNIT);
+#ifdef TCL_PATCH
+      GST_BUFFER_PTS (buf) = timestamp;
+#else
       GST_BUFFER_PTS (buf) = GST_CLOCK_TIME_NONE;
+#endif
     }
 
     GST_BUFFER_DTS (buf) = timestamp;
@@ -5354,6 +5514,20 @@ gst_avi_demux_loop_data (GstAviDemux * avi)
     if (stream->alignment > 1)
       buf = gst_avi_demux_align_buffer (avi, buf, stream->alignment);
     ret = gst_pad_push (stream->pad, buf);
+#if TCL_PATCH
+    #if 0
+    if(stream->pad)
+        ret = gst_pad_push (stream->pad, buf);
+    else if(NULL == stream->pad || TRUE == stream->droped_flag || TRUE == stream->discont)
+    {
+        gst_buffer_unref (buf);
+        ret = GST_FLOW_OK;
+    }
+
+    if(GST_FLOW_OK != ret && TRUE == stream->droped_flag)
+        ret = GST_FLOW_OK;
+    #endif
+#endif
 
     /* mark as processed, we increment the frame and byte counters then
      * leave the while loop and return the GstFlowReturn */
@@ -5515,6 +5689,13 @@ gst_avi_demux_stream_data (GstAviDemux * avi)
           gst_adapter_flush (avi->adapter, 8);
           return GST_FLOW_OK;
         }
+
+#ifdef TCL_PATCH
+        else {
+          gst_adapter_flush (avi->adapter, 8);
+          continue;
+        }
+#endif
       } else {
         return GST_FLOW_OK;
       }
@@ -5594,8 +5775,18 @@ gst_avi_demux_stream_data (GstAviDemux * avi)
         /* as in pull mode, 'total' is either bytes (CBR) or frames (VBR) */
         if (stream->strh->type == GST_RIFF_FCC_auds && stream->is_vbr) {
           gint blockalign = stream->strf.auds->blockalign;
+#ifdef TCL_PATCH
+          if (blockalign > 0) {
+            guint32 blocks = DIV_ROUND_UP (size, blockalign);
+            if (stream->strf.auds->format == GST_RIFF_WAVE_FORMAT_VORBIS) {
+              stream->current_total += blocks > 0 ? blocks : 1;
+            } else
+              stream->current_total += blocks;
+          }
+#else
           if (blockalign > 0)
             stream->current_total += DIV_ROUND_UP (size, blockalign);
+#endif
           else
             stream->current_total++;
         } else {
@@ -5617,7 +5808,11 @@ gst_avi_demux_stream_data (GstAviDemux * avi)
               (gint64 *) & dur_ts);
 
           GST_BUFFER_DTS (buf) = next_ts;
+#ifdef TCL_PATCH
+          GST_BUFFER_PTS (buf) = next_ts;
+#else
           GST_BUFFER_PTS (buf) = GST_CLOCK_TIME_NONE;
+#endif
           GST_BUFFER_DURATION (buf) = dur_ts - next_ts;
           if (stream->strh->type == GST_RIFF_FCC_vids) {
             GST_BUFFER_OFFSET (buf) = stream->current_entry - 1;
@@ -6060,3 +6255,74 @@ gst_avi_demux_change_state (GstElement * element, GstStateChange transition)
 done:
   return ret;
 }
+
+#ifdef TCL_PATCH
+static void
+gst_avi_demux_demux_remove_pad(GstElement *element, GstPad *pad)
+{
+    GstAviDemux *demux  =  GST_AVI_DEMUX (element);
+    GST_OBJECT_LOCK (element);
+    GstAviStream *stream2del = NULL;
+    // 遍历记录
+    int index = 0;
+    for (; index < demux->num_streams; index++)
+    {
+        GstAviStream *stream = &demux->stream[index];
+        if(NULL != stream && pad == stream->pad)
+        {
+            stream2del      = stream;
+            break;
+        }
+    }
+
+    GST_OBJECT_UNLOCK (element);
+    // 存在要清除的流
+    if(stream2del)
+    {
+        gst_avi_demux_reset_stream(demux, stream2del);
+        stream2del->pad         = NULL;
+        stream2del->discont     = TRUE;
+        stream2del->droped_flag = TRUE;
+    }
+}
+
+static void
+gst_avi_demux_set_property (GObject * object,
+    guint prop_id, const GValue * value, GParamSpec * pspec)
+{
+   GstAviDemux *demux;
+
+  demux = GST_AVI_DEMUX (object);
+
+  switch (prop_id) {
+    case PROP_SEEKABLE:
+      GST_OBJECT_LOCK (demux);
+      demux->is_seekable = g_value_get_boolean (value);
+      GST_OBJECT_UNLOCK (demux);
+      break;
+
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+  }
+}
+
+static void
+gst_avi_demux_get_property (GObject * object,
+    guint prop_id, GValue * value, GParamSpec * pspec)
+{
+  GstAviDemux *demux;
+  demux = GST_AVI_DEMUX (object);
+  switch (prop_id) {
+    case PROP_SEEKABLE:
+      GST_OBJECT_LOCK (demux);
+      g_value_set_boolean (value, demux->is_seekable);
+      GST_OBJECT_UNLOCK (demux);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+  }
+}
+
+#endif
diff --git a/subprojects/gst-plugins-good/gst/avi/gstavidemux.h b/subprojects/gst-plugins-good/gst/avi/gstavidemux.h
index 22e46a2edc..c36cc33e88 100644
--- a/subprojects/gst-plugins-good/gst/avi/gstavidemux.h
+++ b/subprojects/gst-plugins-good/gst/avi/gstavidemux.h
@@ -121,6 +121,9 @@ typedef struct {
   gint           index_id;
   gboolean is_raw;
   gsize alignment;
+#ifdef TCL_PATCH
+  gboolean       droped_flag;
+#endif
 } GstAviStream;
 
 typedef enum {
@@ -181,6 +184,12 @@ typedef struct _GstAviDemux {
   gst_riff_avih *avih;
   GstClockTime   duration;
 
+#ifdef TCL_PATCH
+  GstClockTime   audio_hdr_duration;
+  GstClockTime   video_hdr_duration;
+  gboolean       is_seekable;
+  char           platform_val[128];
+#endif
   /* segment in TIME */
   GstSegment     segment;
   guint32        segment_seqnum;
diff --git a/subprojects/gst-plugins-good/gst/flv/gstflvdemux.c b/subprojects/gst-plugins-good/gst/flv/gstflvdemux.c
index 29db7b97dd..ea4f95ae94 100644
--- a/subprojects/gst-plugins-good/gst/flv/gstflvdemux.c
+++ b/subprojects/gst-plugins-good/gst/flv/gstflvdemux.c
@@ -1444,7 +1444,20 @@ gst_flv_demux_video_negotiate (GstFlvDemux * demux, guint32 codec_tag)
           gst_caps_new_simple ("video/mpeg", "mpegversion", G_TYPE_INT, 4,
           "systemstream", G_TYPE_BOOLEAN, FALSE, NULL);
       break;
+    case 12:
+      if (!demux->video_codec_data) {
+        GST_ERROR_OBJECT (demux, "don't have h265 codec data yet");
+        ret = TRUE;
+        goto done;
+      }
+      caps = gst_caps_new_simple ("video/x-h265", "stream-format", G_TYPE_STRING, "byte-stream", NULL);
+      break;
     default:
+#ifdef TCL_PATCH
+      /*modify for the video, which has only audio stream, no video stream*/
+      caps = gst_caps_new_simple ("video/fake", NULL);
+      gst_element_post_message (GST_ELEMENT_CAST (demux), gst_message_new_custom (GST_MESSAGE_DECODE_VIDEO_UNSUPPORT, GST_OBJECT(demux), NULL));
+#endif
       GST_WARNING_OBJECT (demux, "unsupported video codec tag %u", codec_tag);
   }
 
@@ -1589,7 +1602,7 @@ gst_flv_demux_parse_tag_video (GstFlvDemux * demux, GstBuffer * buffer)
   codec_tag = flags & 0x0F;
   if (codec_tag == 4 || codec_tag == 5) {
     codec_data = 2;
-  } else if (codec_tag == 7) {
+  } else if (codec_tag == 7 || codec_tag == 12) {
     codec_data = 5;
 
     cts = GST_READ_UINT24_BE (data + 9);
@@ -1607,7 +1620,7 @@ gst_flv_demux_parse_tag_video (GstFlvDemux * demux, GstBuffer * buffer)
   GST_LOG_OBJECT (demux, "video tag with codec tag %u, keyframe (%d) "
       "(flags %02X)", codec_tag, keyframe, flags);
 
-  if (codec_tag == 7) {
+  if (codec_tag == 7 || codec_tag == 12) {
     guint8 avc_packet_type = GST_READ_UINT8 (data + 8);
 
     switch (avc_packet_type) {
diff --git a/subprojects/gst-plugins-good/gst/isomp4/fourcc.h b/subprojects/gst-plugins-good/gst/isomp4/fourcc.h
index 5be6921e7d..835f51ec52 100644
--- a/subprojects/gst-plugins-good/gst/isomp4/fourcc.h
+++ b/subprojects/gst-plugins-good/gst/isomp4/fourcc.h
@@ -417,6 +417,11 @@ G_BEGIN_DECLS
 #define FOURCC_aavd     GST_MAKE_FOURCC('a','a','v','d')
 #define FOURCC_adrm     GST_MAKE_FOURCC('a','d','r','m')
 
+#ifdef TCL_PATCH
+#define FOURCC_dvvC     GST_MAKE_FOURCC('d','v','v','C')
+#define FOURCC_dvwC     GST_MAKE_FOURCC('d','v','w','C')
+#define FOURCC_dav1     GST_MAKE_FOURCC('d','a','v','1')
+#endif
 G_END_DECLS
 
 #endif /* __FOURCC_H__ */
diff --git a/subprojects/gst-plugins-good/gst/isomp4/gstavprotocol.c b/subprojects/gst-plugins-good/gst/isomp4/gstavprotocol.c
new file mode 100644
index 0000000000..7d742cb30b
--- /dev/null
+++ b/subprojects/gst-plugins-good/gst/isomp4/gstavprotocol.c
@@ -0,0 +1,388 @@
+/* GStreamer
+ * Copyright (C) <1999> Erik Walthinsen <omega@cse.ogi.edu>
+ *               <2006> Edward Hervey <bilboed@bilboed.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+#include <string.h>
+#include <errno.h>
+
+#include <gst/gst.h>
+
+#include "gstavprotocol.h"
+
+typedef struct _GstProtocolInfo GstProtocolInfo;
+
+struct _GstProtocolInfo
+{
+  GstPad *pad;
+
+  guint64 offset;
+  gboolean eos;
+  gint set_streamheader;
+};
+
+static int
+gst_ffmpegdata_peek (void *priv_data, unsigned char *buf, int size)
+{
+  GstProtocolInfo *info;
+  GstBuffer *inbuf = NULL;
+  GstFlowReturn ret;
+  int total = 0;
+
+  info = (GstProtocolInfo *) priv_data;
+
+  GST_DEBUG ("Pulling %d bytes at position %" G_GUINT64_FORMAT, size,
+      info->offset);
+
+  ret = gst_pad_pull_range (info->pad, info->offset, (guint) size, &inbuf);
+
+  switch (ret) {
+    case GST_FLOW_OK:
+      total = (gint) gst_buffer_get_size (inbuf);
+      gst_buffer_extract (inbuf, 0, buf, total);
+      gst_buffer_unref (inbuf);
+      break;
+    case GST_FLOW_EOS:
+      total = 0;
+      break;
+    case GST_FLOW_FLUSHING:
+      total = -1;
+      break;
+    default:
+    case GST_FLOW_ERROR:
+      total = -2;
+      break;
+  }
+
+  GST_DEBUG ("Got %d (%s) return result %d", ret, gst_flow_get_name (ret),
+      total);
+
+  return total;
+}
+
+static int
+gst_ffmpegdata_read (void *priv_data, unsigned char *buf, int size)
+{
+  gint res;
+  GstProtocolInfo *info;
+
+  info = (GstProtocolInfo *) priv_data;
+
+  GST_DEBUG ("Reading %d bytes of data at position %" G_GUINT64_FORMAT, size,
+      info->offset);
+
+  res = gst_ffmpegdata_peek (priv_data, buf, size);
+  if (res >= 0)
+    info->offset += res;
+
+  GST_DEBUG ("Returning %d bytes", res);
+
+  return res;
+}
+
+static int
+gst_ffmpegdata_write (void *priv_data, uint8_t * buf, int size)
+{
+  GstProtocolInfo *info;
+  GstBuffer *outbuf;
+
+  GST_DEBUG ("Writing %d bytes", size);
+  info = (GstProtocolInfo *) priv_data;
+
+  /* create buffer and push data further */
+  outbuf = gst_buffer_new_and_alloc (size);
+
+  gst_buffer_fill (outbuf, 0, buf, size);
+
+  if (gst_pad_push (info->pad, outbuf) != GST_FLOW_OK)
+    return 0;
+
+  info->offset += size;
+  return size;
+}
+
+static int64_t
+gst_ffmpegdata_seek (void *priv_data, int64_t pos, int whence)
+{
+  GstProtocolInfo *info;
+  guint64 newpos = 0, oldpos;
+
+  GST_DEBUG ("Seeking to %" G_GINT64_FORMAT ", whence=%d",
+      (gint64) pos, whence);
+
+  info = (GstProtocolInfo *) priv_data;
+
+  /* TODO : if we are push-based, we need to return sensible info */
+
+  if (GST_PAD_IS_SINK (info->pad)) {
+    /* sinkpad */
+    switch (whence) {
+      case SEEK_SET:
+        newpos = (guint64) pos;
+        break;
+      case SEEK_CUR:
+        newpos = info->offset + pos;
+        break;
+      case SEEK_END:
+      case AVSEEK_SIZE:
+        /* ffmpeg wants to know the current end position in bytes ! */
+      {
+        gint64 duration;
+
+        GST_DEBUG ("Seek end");
+
+        if (gst_pad_is_linked (info->pad))
+          if (gst_pad_query_duration (GST_PAD_PEER (info->pad),
+                  GST_FORMAT_BYTES, &duration))
+            newpos = ((guint64) duration) + pos;
+      }
+        break;
+      default:
+        g_assert (0);
+        break;
+    }
+    /* FIXME : implement case for push-based behaviour */
+    if (whence != AVSEEK_SIZE)
+      info->offset = newpos;
+  } else if (GST_PAD_IS_SRC (info->pad)) {
+    GstSegment segment;
+
+    oldpos = info->offset;
+
+    /* srcpad */
+    switch (whence) {
+      case SEEK_SET:
+      {
+        info->offset = (guint64) pos;
+        break;
+      }
+      case SEEK_CUR:
+        info->offset += pos;
+        break;
+      default:
+        break;
+    }
+    newpos = info->offset;
+
+    if (newpos != oldpos) {
+      gst_segment_init (&segment, GST_FORMAT_BYTES);
+      segment.start = newpos;
+      segment.time = newpos;
+      gst_pad_push_event (info->pad, gst_event_new_segment (&segment));
+    }
+  } else {
+    g_assert_not_reached ();
+  }
+
+  GST_DEBUG ("Now at offset %" G_GUINT64_FORMAT " (returning %" G_GUINT64_FORMAT
+      ")", info->offset, newpos);
+  return newpos;
+}
+
+int
+gst_ffmpegdata_close (AVIOContext * h)
+{
+  GstProtocolInfo *info;
+
+  if (h == NULL)
+    return 0;
+
+  info = (GstProtocolInfo *) h->opaque;
+  if (info == NULL)
+    return 0;
+
+  GST_LOG ("Closing file");
+
+  if (GST_PAD_IS_SRC (info->pad)) {
+    /* send EOS - that closes down the stream */
+    gst_pad_push_event (info->pad, gst_event_new_eos ());
+  }
+
+  /* clean up data */
+  g_free (info);
+  h->opaque = NULL;
+
+  av_freep (&h->buffer);
+  av_free (h);
+
+  return 0;
+}
+
+int
+gst_ffmpegdata_open (GstPad * pad, int flags, AVIOContext ** context)
+{
+  GstProtocolInfo *info;
+
+#ifdef TCL_PATCH
+  static const int buffer_size = 4096 * 16;
+#else
+  static const int buffer_size = 4096;
+#endif
+  unsigned char *buffer = NULL;
+
+  info = g_new0 (GstProtocolInfo, 1);
+  if (!info) {
+      GST_ERROR("info g_new0 ERROR");
+      return -EINVAL;
+  }
+
+  info->set_streamheader = flags & GST_FFMPEG_URL_STREAMHEADER;
+  flags &= ~GST_FFMPEG_URL_STREAMHEADER;
+
+  /* we don't support R/W together */
+  if ((flags & AVIO_FLAG_WRITE) && (flags & AVIO_FLAG_READ)) {
+    GST_WARNING ("Only read-only or write-only are supported");
+    g_free (info);
+    return -EINVAL;
+  }
+
+  /* make sure we're a pad and that we're of the right type */
+  g_return_val_if_fail (GST_IS_PAD (pad), -EINVAL);
+
+  if ((flags & AVIO_FLAG_READ)) {
+      if (!GST_PAD_IS_SINK (pad)) {
+          GST_ERROR("GST_PAD_IS_SINK ERROR");
+          g_free (info);
+          return -EINVAL;
+      }
+  }
+//    g_return_val_if_fail (GST_PAD_IS_SINK (pad), -EINVAL);
+
+  if ((flags & AVIO_FLAG_WRITE)) {
+      if (!GST_PAD_IS_SRC (pad)) {
+          GST_ERROR("GST_PAD_IS_SRC ERROR");
+          g_free (info);
+          return -EINVAL;
+      }
+  }
+//    g_return_val_if_fail (GST_PAD_IS_SRC (pad), -EINVAL);
+
+  info->eos = FALSE;
+  info->pad = pad;
+  info->offset = 0;
+
+  buffer = av_malloc (buffer_size);
+  if (buffer == NULL) {
+    GST_WARNING ("Failed to allocate buffer");
+    g_free (info);
+    return -ENOMEM;
+  }
+
+  *context =
+      avio_alloc_context (buffer, buffer_size, flags, (void *) info,
+      gst_ffmpegdata_read, gst_ffmpegdata_write, gst_ffmpegdata_seek);
+  if (*context == NULL) {
+    GST_WARNING ("Failed to allocate memory");
+    g_free (info);
+    av_free (buffer);
+    return -ENOMEM;
+  }
+  (*context)->seekable = AVIO_SEEKABLE_NORMAL;
+  if (!(flags & AVIO_FLAG_WRITE)) {
+    (*context)->buf_ptr = (*context)->buf_end;
+    (*context)->write_flag = 0;
+  }
+
+  return 0;
+}
+
+/* specialized protocol for cross-thread pushing,
+ * based on ffmpeg's pipe protocol */
+
+static int
+gst_ffmpeg_pipe_read (void *priv_data, uint8_t * buf, int size)
+{
+  GstFFMpegPipe *ffpipe;
+  guint available;
+
+  ffpipe = (GstFFMpegPipe *) priv_data;
+
+  GST_LOG ("requested size %d", size);
+
+  GST_FFMPEG_PIPE_MUTEX_LOCK (ffpipe);
+
+  GST_LOG ("requested size %d", size);
+
+  while ((available = gst_adapter_available (ffpipe->adapter)) < size
+      && !ffpipe->eos) {
+    GST_DEBUG ("Available:%d, requested:%d", available, size);
+    ffpipe->needed = size;
+    GST_FFMPEG_PIPE_SIGNAL (ffpipe);
+    GST_FFMPEG_PIPE_WAIT (ffpipe);
+  }
+
+  size = MIN (available, size);
+  if (size) {
+    GST_LOG ("Getting %d bytes", size);
+    gst_adapter_copy (ffpipe->adapter, buf, 0, size);
+    gst_adapter_flush (ffpipe->adapter, size);
+    GST_LOG ("%" G_GSIZE_FORMAT " bytes left in adapter",
+        gst_adapter_available (ffpipe->adapter));
+    ffpipe->needed = 0;
+  }
+  GST_FFMPEG_PIPE_MUTEX_UNLOCK (ffpipe);
+
+  return size;
+}
+
+int
+gst_ffmpeg_pipe_close (AVIOContext * h)
+{
+  GST_LOG ("Closing pipe");
+
+  if (h == NULL)
+    return 0;
+
+  h->opaque = NULL;
+  av_freep (&h->buffer);
+  av_free (h);
+
+  return 0;
+}
+
+int
+gst_ffmpeg_pipe_open (GstFFMpegPipe * ffpipe, int flags, AVIOContext ** context)
+{
+  static const int buffer_size = 4096;
+  unsigned char *buffer = NULL;
+
+  /* sanity check */
+  g_return_val_if_fail (GST_IS_ADAPTER (ffpipe->adapter), -EINVAL);
+
+  buffer = av_malloc (buffer_size);
+  if (buffer == NULL) {
+    GST_WARNING ("Failed to allocate buffer");
+    return -ENOMEM;
+  }
+
+  *context =
+      avio_alloc_context (buffer, buffer_size, 0, (void *) ffpipe,
+      gst_ffmpeg_pipe_read, NULL, NULL);
+  if (*context == NULL) {
+    GST_WARNING ("Failed to allocate memory");
+    av_free (buffer);
+    return -ENOMEM;
+  }
+  (*context)->seekable = 0;
+  (*context)->buf_ptr = (*context)->buf_end;
+
+  return 0;
+}
diff --git a/subprojects/gst-plugins-good/gst/isomp4/gstavprotocol.h b/subprojects/gst-plugins-good/gst/isomp4/gstavprotocol.h
new file mode 100644
index 0000000000..32a731f57f
--- /dev/null
+++ b/subprojects/gst-plugins-good/gst/isomp4/gstavprotocol.h
@@ -0,0 +1,79 @@
+/* GStreamer
+ * Copyright (C) <2006> Mark Nauwelaerts <manauw@skynet.be>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+
+#ifndef __GST_FFMPEGPROTOCOL_H__
+#define __GST_FFMPEGPROTOCOL_H__
+
+#include <gst/base/gstadapter.h>
+#include <libavformat/avformat.h>
+
+G_BEGIN_DECLS
+#define GST_FFMPEG_URL_STREAMHEADER 16
+
+/* pipe protocol helpers */
+#define GST_FFMPEG_PIPE_MUTEX_LOCK(m) G_STMT_START {                    \
+  GST_LOG ("locking tlock from thread %p", g_thread_self ()); \
+  g_mutex_lock (&m->tlock);                                              \
+  GST_LOG ("locked tlock from thread %p", g_thread_self ());  \
+} G_STMT_END
+
+#define GST_FFMPEG_PIPE_MUTEX_UNLOCK(m) G_STMT_START {                    \
+  GST_LOG ("unlocking tlock from thread %p", g_thread_self ()); \
+  g_mutex_unlock (&m->tlock);                                              \
+} G_STMT_END
+
+#define GST_FFMPEG_PIPE_WAIT(m) G_STMT_START {                          \
+  GST_LOG ("thread %p waiting", g_thread_self ());            \
+  g_cond_wait (&m->cond, &m->tlock);                                      \
+} G_STMT_END
+
+#define GST_FFMPEG_PIPE_SIGNAL(m) G_STMT_START {                        \
+  GST_LOG ("signalling from thread %p", g_thread_self ());    \
+  g_cond_signal (&m->cond);                                              \
+} G_STMT_END
+
+typedef struct _GstFFMpegPipe GstFFMpegPipe;
+
+struct _GstFFMpegPipe
+{
+  /* lock for syncing */
+  GMutex tlock;
+  /* with TLOCK */
+  /* signals counterpart thread to have a look */
+  GCond cond;
+  /* seen eos */
+  gboolean eos;
+  /* flowreturn obtained by src task */
+  GstFlowReturn srcresult;
+  /* adpater collecting data */
+  GstAdapter *adapter;
+  /* amount needed in adapter by src task */
+  guint needed;
+};
+
+int gst_ffmpeg_pipe_open (GstFFMpegPipe *ffpipe, int flags, AVIOContext ** context);
+int gst_ffmpeg_pipe_close (AVIOContext * h);
+
+int gst_ffmpegdata_open (GstPad * pad, int flags, AVIOContext ** context);
+int gst_ffmpegdata_close (AVIOContext * h);
+
+G_END_DECLS
+
+#endif /* __GST_FFMPEGPROTOCOL_H__ */
diff --git a/subprojects/gst-plugins-good/gst/isomp4/isomp4-plugin.c b/subprojects/gst-plugins-good/gst/isomp4/isomp4-plugin.c
index 3694d157b2..b6bfeaf870 100644
--- a/subprojects/gst-plugins-good/gst/isomp4/isomp4-plugin.c
+++ b/subprojects/gst-plugins-good/gst/isomp4/isomp4-plugin.c
@@ -33,9 +33,11 @@ plugin_init (GstPlugin * plugin)
   gboolean ret = FALSE;
 
   ret |= GST_ELEMENT_REGISTER (qtdemux, plugin);
+#ifndef TCL_PATCH
   ret |= GST_ELEMENT_REGISTER (rtpxqtdepay, plugin);
   ret |= GST_ELEMENT_REGISTER (qtmux, plugin);
   ret |= GST_ELEMENT_REGISTER (qtmoovrecover, plugin);
+#endif
 
   return ret;
 }
diff --git a/subprojects/gst-plugins-good/gst/isomp4/meson.build b/subprojects/gst-plugins-good/gst/isomp4/meson.build
index b10c09c406..55bcbbe4f0 100644
--- a/subprojects/gst-plugins-good/gst/isomp4/meson.build
+++ b/subprojects/gst-plugins-good/gst/isomp4/meson.build
@@ -16,16 +16,31 @@ mp4_sources = [
   'atomsrecovery.c',
   'descriptors.c',
   'properties.c',
-  'gstqtmuxmap.c'
+  'gstqtmuxmap.c',
+  'gstavprotocol.c',
 ]
 
+libavfilter_dep = dependency('libavfilter', version: '>= 7.16.100',
+  fallback: ['FFmpeg', 'libavfilter_dep'])
+libavformat_dep = dependency('libavformat', version: '>= 58.12.100',
+  fallback: ['FFmpeg', 'libavformat_dep'])
+libavcodec_dep = dependency('libavcodec', version: '>= 58.18.100',
+  fallback: ['FFmpeg', 'libavcodec_dep'])
+libavutil_dep = dependency('libavutil', version: '>= 56.14.100',
+  fallback: ['FFmpeg', 'libavutil_dep'])
+
+libav_deps = [libavfilter_dep, libavformat_dep, libavcodec_dep, libavutil_dep]
+
+cc = meson.get_compiler('c')
+liblog = cc.find_library('log', required : true)
+
 gstisomp4 = library('gstisomp4',
   mp4_sources,
   c_args : gst_plugins_good_args,
   link_args : noseh_link_args,
   include_directories : [configinc, libsinc],
-  dependencies : [gst_dep, gstriff_dep, gstaudio_dep, gstvideo_dep,
-                  gstrtp_dep, gsttag_dep, gstpbutils_dep, zlib_dep],
+  dependencies : [libav_deps, gst_dep, gstriff_dep, gstaudio_dep, gstvideo_dep,
+                  gstrtp_dep, gsttag_dep, gstpbutils_dep, zlib_dep, liblog],
   install : true,
   install_dir : plugins_install_dir,
 )
diff --git a/subprojects/gst-plugins-good/gst/isomp4/qtdemux.c b/subprojects/gst-plugins-good/gst/isomp4/qtdemux.c
index 1a8ecb9055..0836feba9b 100644
--- a/subprojects/gst-plugins-good/gst/isomp4/qtdemux.c
+++ b/subprojects/gst-plugins-good/gst/isomp4/qtdemux.c
@@ -78,6 +78,10 @@
 #include <math.h>
 #include <gst/math-compat.h>
 
+#ifdef TCL_PATCH
+#include "gstavprotocol.h"
+#endif
+
 #ifdef HAVE_ZLIB
 # include <zlib.h>
 #endif
@@ -115,6 +119,16 @@ GST_DEBUG_CATEGORY (qtdemux_debug);
 typedef struct _QtDemuxCencSampleSetInfo QtDemuxCencSampleSetInfo;
 typedef struct _QtDemuxAavdEncryptionInfo QtDemuxAavdEncryptionInfo;
 
+#ifdef TCL_PATCH
+enum
+{
+  PROP_0,
+  PROP_LATEST_PUSHED_BUFFER_PTS,
+  PROP_SEEKABLE,
+  /* FILL ME */
+};
+#endif
+
 /* Macros for converting to/from timescale */
 #define QTSTREAMTIME_TO_GSTTIME(stream, value) (gst_util_uint64_scale((value), GST_SECOND, (stream)->timescale))
 #define GSTTIME_TO_QTSTREAMTIME(stream, value) (gst_util_uint64_scale((value), (stream)->timescale, GST_SECOND))
@@ -263,6 +277,12 @@ static GstFlowReturn qtdemux_add_fragmented_samples (GstQTDemux * qtdemux);
 
 static void gst_qtdemux_check_send_pending_segment (GstQTDemux * demux);
 
+#ifdef TCL_PATCH
+static void gst_qtdemux_demux_remove_pad(GstElement *element, GstPad *pad);
+
+static void gst_qtdemux_get_video_buffered_time(GstQTDemux * qtdemux);
+#endif
+
 static GstStaticPadTemplate gst_qtdemux_sink_template =
     GST_STATIC_PAD_TEMPLATE ("sink",
     GST_PAD_SINK,
@@ -384,6 +404,50 @@ static void gst_qtdemux_append_protection_system_id (GstQTDemux * qtdemux,
 static void qtdemux_gst_structure_free (GstStructure * gststructure);
 static void gst_qtdemux_reset (GstQTDemux * qtdemux, gboolean hard);
 
+#ifdef TCL_PATCH
+static void gst_qtdemux_set_property (GObject * object, guint prop_id,
+    const GValue * value, GParamSpec * pspec);
+
+static void gst_qtdemux_get_property (GObject * object, guint prop_id,
+    GValue * value, GParamSpec * pspec);
+
+static void
+gst_qtdemux_set_property (GObject * object, guint prop_id,
+    const GValue * value, GParamSpec * pspec)
+{
+  GstQTDemux *demux = GST_QTDEMUX (object);
+
+  switch (prop_id) {
+    case PROP_LATEST_PUSHED_BUFFER_PTS:
+      demux->latest_pushed_buffer_pts= g_value_get_uint (value);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+  }
+}
+
+static void
+gst_qtdemux_get_property (GObject * object, guint prop_id,
+    GValue * value, GParamSpec * pspec)
+{
+  GstQTDemux *demux = GST_QTDEMUX (object);
+
+  switch (prop_id) {
+    case PROP_LATEST_PUSHED_BUFFER_PTS:
+      gst_qtdemux_get_video_buffered_time(demux);
+      GST_DEBUG_OBJECT (demux, "latest-pushed-buffer-pts %lld(buffer range)", demux->latest_pushed_buffer_pts);
+      g_value_set_uint (value, demux->latest_pushed_buffer_pts);
+      break;
+    case PROP_SEEKABLE:
+      GST_DEBUG_OBJECT (demux, "seekable = %d", demux->seekable);
+      g_value_set_boolean (value, demux->seekable);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+  }
+}
+#endif
+
 static void
 gst_qtdemux_class_init (GstQTDemuxClass * klass)
 {
@@ -398,13 +462,37 @@ gst_qtdemux_class_init (GstQTDemuxClass * klass)
   gobject_class->dispose = gst_qtdemux_dispose;
   gobject_class->finalize = gst_qtdemux_finalize;
 
+#ifdef TCL_PATCH
+  gobject_class->set_property = gst_qtdemux_set_property;
+  gobject_class->get_property = gst_qtdemux_get_property;
+#endif
+
   gstelement_class->change_state = GST_DEBUG_FUNCPTR (gst_qtdemux_change_state);
+
+#ifdef TCL_PATCH
+  //  gstelement_class->demux_remove_pad = GST_DEBUG_FUNCPTR (gst_qtdemux_demux_remove_pad);
+#endif
+
 #if 0
   gstelement_class->set_index = GST_DEBUG_FUNCPTR (gst_qtdemux_set_index);
   gstelement_class->get_index = GST_DEBUG_FUNCPTR (gst_qtdemux_get_index);
 #endif
   gstelement_class->set_context = GST_DEBUG_FUNCPTR (gst_qtdemux_set_context);
 
+#ifdef TCL_PATCH
+  g_object_class_install_property (gobject_class, PROP_LATEST_PUSHED_BUFFER_PTS,
+      g_param_spec_uint ("latest-pushed-buffer-pts", "Latest pushed buffer pts",
+          "The pts of the latest pushed buffer pts",
+          0, G_MAXUINT, 0,
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  g_object_class_install_property (gobject_class, PROP_SEEKABLE,
+      g_param_spec_boolean ("is-seekable",
+          "seekable by keyframe",
+          "when there is no keyframe, it is not seekable",
+          FALSE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+#endif
+
   gst_tag_register_musicbrainz_tags ();
 
   gst_element_class_add_static_pad_template (gstelement_class,
@@ -450,6 +538,14 @@ gst_qtdemux_init (GstQTDemux * qtdemux)
   GST_OBJECT_FLAG_SET (qtdemux, GST_ELEMENT_FLAG_INDEXABLE);
 
   gst_qtdemux_reset (qtdemux, TRUE);
+#ifdef TCL_PATCH
+  qtdemux->audio_info = g_new0(media_audio_info_s, 1);
+  qtdemux->video_info = g_new0(media_video_info_s, 1);
+
+  qtdemux->latest_pushed_buffer_pts = 0;
+  qtdemux->seekable = TRUE;
+  qtdemux->hasHevc = FALSE;
+#endif
 }
 
 static void
@@ -995,6 +1091,10 @@ gst_qtdemux_find_keyframe (GstQTDemux * qtdemux, QtDemuxStream * str,
     guint32 index, gboolean next)
 {
   guint32 new_index = index;
+#ifdef TCL_PATCH
+  guint32 before_index = index;
+  guint32 after_index = index;
+#endif
 
   if (index >= str->n_samples) {
     new_index = str->n_samples;
@@ -1024,6 +1124,36 @@ gst_qtdemux_find_keyframe (GstQTDemux * qtdemux, QtDemuxStream * str,
       new_index--;
   }
 
+#if 0
+  before_index = new_index;
+  new_index = index;
+  while (TRUE) {
+    if (str->samples[new_index].keyframe)
+      break;
+
+    if (new_index == str->n_samples - 1)
+      break;
+    new_index++;
+  }
+  after_index = new_index;
+  if ((QTSAMPLE_PTS(str, &str->samples[index]) - QTSAMPLE_PTS(str, &str->samples[before_index]))/2
+    <= (QTSAMPLE_PTS(str, &str->samples[after_index]) - QTSAMPLE_PTS(str, &str->samples[index])))
+  {
+    /* 始终使用后一个I帧，测试用例SUB0010等关于字幕seek到90s后的同步测试，
+     * 在89720-89880ms存在闪烁而FAIL,
+     * 在seek点的后一个I帧将跳过此闪烁点而不会FAIL
+     */
+    if(after_index != (str->n_samples - 1) && str->samples[after_index].keyframe)
+      new_index = after_index;
+    else
+      new_index = before_index;
+  }
+  else
+  {
+    new_index = after_index;
+  }
+#endif
+
   if (new_index == str->n_samples) {
     GST_DEBUG_OBJECT (qtdemux, "no next keyframe");
     new_index = -1;
@@ -1113,10 +1243,29 @@ gst_qtdemux_adjust_seek (GstQTDemux * qtdemux, gint64 desired_time,
 {
   guint64 min_offset;
   gint64 min_byte_offset = -1;
+#ifdef TCL_PATCH
+  gint64 min_byte_aoffset = -1;
+  gint64 min_byte_voffset = -1;
+#endif
   guint i;
 
   min_offset = desired_time;
-
+#ifdef TCL_PATCH
+  gchar *codec = NULL;
+  for (i = 0; i < QTDEMUX_N_STREAMS (qtdemux); i++) {
+      QtDemuxStream *str;
+      str = QTDEMUX_NTH_STREAM (qtdemux, i);
+      if (CUR_STREAM (str)->sparse && !use_sparse)
+        continue;
+      if (gst_tag_list_get_string (str->stream_tags, GST_TAG_VIDEO_CODEC, &codec)) {
+        GST_ERROR("codec =%s",codec);
+        if (!strcmp(codec, "H.265 / HEVC")) {
+          qtdemux->hasHevc = TRUE;
+        }
+        g_free (codec);
+      }
+  }
+#endif
   /* for each stream, find the index of the sample in the segment
    * and move back to the previous keyframe. */
   for (i = 0; i < QTDEMUX_N_STREAMS (qtdemux); i++) {
@@ -1184,7 +1333,13 @@ gst_qtdemux_adjust_seek (GstQTDemux * qtdemux, gint64 desired_time,
       /* Update the requested time whenever a keyframe was found, to make it
        * accurate and avoid having the first buffer fall outside of the segment
        */
+
+      GST_ERROR("kindex=%d",kindex);
+#ifdef TCL_PATCH
+      if (kindex != -1 && str->samples[kindex].keyframe) {
+#else
       if (kindex != -1) {
+#endif
         index = kindex;
 
         /* get timestamp of keyframe */
@@ -1197,23 +1352,57 @@ gst_qtdemux_adjust_seek (GstQTDemux * qtdemux, gint64 desired_time,
         /* keyframes in the segment get a chance to change the
          * desired_offset. keyframes out of the segment are
          * ignored. */
-        if (media_time >= seg->media_start) {
-          GstClockTime seg_time;
-
-          /* this keyframe is inside the segment, convert back to
-           * segment time */
-          seg_time = (media_time - seg->media_start) + seg->time;
-          if ((!next && (seg_time < min_offset)) ||
-              (next && (seg_time > min_offset)))
-            min_offset = seg_time;
+#ifdef TCL_PATCH
+        if (qtdemux->hasHevc && media_time != -1) {
+            min_offset = media_time;
+        } else {
+            if (media_time >= seg->media_start) {
+              GstClockTime seg_time;
+              /* this keyframe is inside the segment, convert back to
+               * segment time */
+              seg_time = (media_time - seg->media_start) + seg->time;
+              if ((!next && (seg_time < min_offset)) ||
+                  (next && (seg_time > min_offset))) {
+                     min_offset = seg_time;
+                 }
+            }
         }
+#else
+      if (media_time >= seg->media_start) {
+        GstClockTime seg_time;
+        /* this keyframe is inside the segment, convert back to
+         * segment time */
+        seg_time = (media_time - seg->media_start) + seg->time;
+        if ((!next && (seg_time < min_offset)) ||
+            (next && (seg_time > min_offset)))
+               min_offset = seg_time;
+      }
+#endif
       }
     }
 
+#ifdef TCL_PATCH
+    if (str->subtype == FOURCC_vide && (min_byte_voffset < 0 || str->samples[index].offset < min_byte_voffset))
+    {
+        min_byte_voffset = str->samples[index].offset;
+    }
+    if (str->subtype == FOURCC_soun && (min_byte_aoffset < 0 || str->samples[index].offset < min_byte_aoffset))
+    {
+        min_byte_aoffset = str->samples[index].offset;
+    }
+#else
     if (min_byte_offset < 0 || str->samples[index].offset < min_byte_offset)
       min_byte_offset = str->samples[index].offset;
+#endif
   }
 
+#ifdef TCL_PATCH
+  if (min_byte_voffset >= 0)
+    min_byte_offset = min_byte_voffset;
+  else if (min_byte_aoffset >= 0)
+    min_byte_offset = min_byte_aoffset;
+#endif
+
   if (key_time)
     *key_time = min_offset;
   if (key_offset)
@@ -1870,6 +2059,9 @@ _create_stream (GstQTDemux * demux, guint32 track_id)
   gst_tag_list_set_scope (stream->stream_tags, GST_TAG_SCOPE_STREAM);
   g_queue_init (&stream->protection_scheme_event_queue);
   stream->ref_count = 1;
+#ifdef TCL_PATCH
+  stream->pts_shift = 0;
+#endif
   /* consistent default for push based mode */
   gst_segment_init (&stream->segment, GST_FORMAT_TIME);
   return stream;
@@ -2008,6 +2200,7 @@ gst_qtdemux_reset (GstQTDemux * qtdemux, gboolean hard)
         g_free (qtdemux->moov_node->data);
     }
     qtdemux->moov_node_compressed = NULL;
+
     if (qtdemux->moov_node)
       g_node_destroy (qtdemux->moov_node);
     qtdemux->moov_node = NULL;
@@ -2032,6 +2225,10 @@ gst_qtdemux_reset (GstQTDemux * qtdemux, gboolean hard)
     qtdemux->chapters_track_id = 0;
     qtdemux->have_group_id = FALSE;
     qtdemux->group_id = G_MAXUINT;
+#ifdef TCL_PATCH
+    qtdemux->seekable = TRUE;
+    qtdemux->hasHevc = FALSE;
+#endif
 
     g_queue_foreach (&qtdemux->protection_event_queue, (GFunc) gst_event_unref,
         NULL);
@@ -2634,6 +2831,18 @@ gst_qtdemux_change_state (GstElement * element, GstStateChange transition)
   switch (transition) {
     case GST_STATE_CHANGE_PAUSED_TO_READY:{
       gst_qtdemux_reset (qtdemux, TRUE);
+#ifdef TCL_PATCH
+      if(qtdemux->audio_info)
+      {
+        g_free(qtdemux->audio_info);
+        qtdemux->audio_info =NULL;
+      }
+      if(qtdemux->video_info)
+      {
+        g_free(qtdemux->video_info);
+        qtdemux->video_info =NULL;
+      }
+#endif
       break;
     }
     default:
@@ -5237,8 +5446,26 @@ gst_qtdemux_prepare_current_sample (GstQTDemux * qtdemux,
   /* now get the info for the sample we're at */
   sample = &stream->samples[stream->sample_index];
 
+#ifdef TCL_PATCH
+  if (stream->sample_index == 0) {
+    GstStructure* structure = gst_caps_get_structure(CUR_STREAM (stream)->caps, 0);
+    const gchar *name = gst_structure_get_name(structure);
+    if (name && (!strncmp (name, "video/x-h264", 12) || !strncmp (name, "video/x-h265", 12))) {
+      gint32 first_pts_offset = (stream)->cslg_shift + (sample)->pts_offset;
+      guint64 first_time_offset = QTSTREAMTIME_TO_GSTTIME((stream), first_pts_offset);
+      if (first_pts_offset > 0 && first_time_offset < 200000000) {
+        GST_INFO_OBJECT (qtdemux, "set pts_shift pts_shift to:-%d first_time:%lld ns", first_pts_offset, first_time_offset);
+        stream->pts_shift = -first_pts_offset;
+      }
+    }
+  }
+#endif
   *dts = QTSAMPLE_DTS (stream, sample);
+#ifdef TCL_PATCH
+  *pts = QTSTREAMTIME_TO_GSTTIME((stream), (sample)->timestamp + (stream)->cslg_shift + (sample)->pts_offset + stream->pts_shift);
+#else
   *pts = QTSAMPLE_PTS (stream, sample);
+#endif
   *offset = sample->offset;
   *size = sample->size;
   *duration = QTSAMPLE_DUR_DTS (stream, sample, *dts);
@@ -5951,6 +6178,28 @@ gst_qtdemux_push_buffer (GstQTDemux * qtdemux, QtDemuxStream * stream,
 
   ret = gst_pad_push (stream->pad, buf);
 
+#ifdef TCL_PATCH
+#if 0
+    if(stream->pad)
+    {
+      gchar *name = gst_caps_to_string (gst_pad_get_current_caps(stream->pad));
+      GST_DEBUG_OBJECT (qtdemux, "check pad caps(%s)", name);
+
+      if(strstr(name,"video/"))
+      {
+        if(!GST_BUFFER_FLAG_IS_SET(buf,GST_BUFFER_FLAG_DELTA_UNIT)){
+            g_print(
+                "Pushing I frame buffer with dts %" GST_TIME_FORMAT ", pts %" GST_TIME_FORMAT
+                ", duration %" GST_TIME_FORMAT " on pad %s\n", GST_TIME_ARGS (dts),
+                GST_TIME_ARGS (pts), GST_TIME_ARGS (duration),
+                GST_PAD_NAME (stream->pad));
+        }
+      }
+      g_free (name);
+    }
+#endif
+#endif
+
   if (GST_CLOCK_TIME_IS_VALID (pts) && GST_CLOCK_TIME_IS_VALID (duration)) {
     /* mark position in stream, we'll need this to know when to send GAP event */
     stream->segment.position = pts + duration;
@@ -6206,6 +6455,73 @@ exit:
   return ret;
 }
 
+#ifdef TCL_PATCH
+static void
+gst_qtdemux_get_video_buffered_time(GstQTDemux * qtdemux)
+{
+
+#if 0
+    int i;
+    for (i = 0; i < qtdemux->n_streams; i++) {
+      QtDemuxStream *stream = qtdemux->streams[i];
+
+      if(stream->pad)
+      {
+        gchar *name = gst_caps_to_string (gst_pad_get_current_caps(stream->pad));
+        GST_DEBUG_OBJECT (qtdemux, "check pad caps(%s)", name);
+
+        if(strstr(name,"video/"))
+        {
+            //±éÀú stream µÄ»º³å
+            int nb_buffers=0;
+            int update_flag=0;
+            GSList *walk;
+            for (walk = stream->buffers; walk; walk = g_slist_next (walk))
+            {
+                nb_buffers+=1;
+                if(NULL != g_slist_next (walk))
+                    continue;
+
+                GstBuffer *buffer = (GstBuffer *) stream->buffers->data;
+
+                qtdemux->latest_pushed_buffer_pts = GST_BUFFER_PTS (buffer);
+                GST_DEBUG_OBJECT (qtdemux, "update VIDEO latest_pushed_buffer_pts to %lld(millisecond)", qtdemux->latest_pushed_buffer_pts/GST_MSECOND);
+                update_flag=1;
+            }
+
+
+            if(!update_flag)
+            {
+                QtDemuxSample *sample;
+                GST_DEBUG_OBJECT (qtdemux, "cached %d buffers", nb_buffers);
+                sample = &stream->samples[stream->sample_index+nb_buffers];
+
+                if (G_LIKELY (!(STREAM_IS_EOS (stream)))) {
+                  GST_DEBUG_OBJECT (qtdemux, "stream : %" GST_FOURCC_FORMAT,
+                      GST_FOURCC_ARGS (stream->fourcc));
+
+                  qtdemux->latest_pushed_buffer_pts = QTSAMPLE_PTS (stream, sample);
+                  GST_DEBUG_OBJECT (qtdemux, "update VIDEO latest_pushed_buffer_pts to %lld(millisecond)", qtdemux->latest_pushed_buffer_pts/GST_MSECOND);
+                }
+            }
+        }
+        g_free (name);
+      }
+    }
+#else
+  GstQuery *query;
+  query = gst_query_new_position (GST_FORMAT_PERCENT);
+  gst_pad_peer_query (qtdemux->sinkpad, query);
+  gint64 percent_int;
+  gst_query_parse_position (query, NULL, &percent_int);
+  double percent_double = (double)percent_int/(double)GST_FORMAT_PERCENT_MAX;
+  gst_query_unref (query);
+  GST_INFO_OBJECT (qtdemux, "percent of download is %f", percent_double);
+  qtdemux->latest_pushed_buffer_pts = (guint64) percent_int;
+#endif
+}
+#endif
+
 static const QtDemuxRandomAccessEntry *
 gst_qtdemux_stream_seek_fragment (GstQTDemux * qtdemux, QtDemuxStream * stream,
     GstClockTime pos, gboolean after)
@@ -8153,6 +8469,9 @@ qtdemux_parse_node (GstQTDemux * qtdemux, GNode * node, const guint8 * buffer,
       case FOURCC_hev1:
       case FOURCC_dvh1:
       case FOURCC_dvhe:
+#ifdef TCL_PATCH
+      case FOURCC_dav1:
+#endif
       case FOURCC_mjp2:
       case FOURCC_encv:
       {
@@ -8624,7 +8943,14 @@ gst_qtdemux_guess_framerate (GstQTDemux * qtdemux, QtDemuxStream * stream)
       fps_available =
           gst_video_guess_framerate (avg_duration,
           &CUR_STREAM (stream)->fps_n, &CUR_STREAM (stream)->fps_d);
-
+#ifdef TCL_PATCH
+      if (!fps_available) {
+          if ((CUR_STREAM (stream)->fps_n == 10000 && CUR_STREAM (stream)->fps_d == 423) ||
+             (CUR_STREAM (stream)->fps_n == 100000 && CUR_STREAM (stream)->fps_d == 3321)) {
+              fps_available = TRUE;
+          }
+      }
+#endif
       GST_DEBUG_OBJECT (qtdemux,
           "Calculating framerate, timescale %u gave fps_n %d fps_d %d",
           stream->timescale, CUR_STREAM (stream)->fps_n,
@@ -8829,6 +9155,27 @@ gst_qtdemux_configure_stream (GstQTDemux * qtdemux, QtDemuxStream * stream)
 
     GST_DEBUG_OBJECT (qtdemux, "setting caps %" GST_PTR_FORMAT,
         CUR_STREAM (stream)->caps);
+
+#ifdef TCL_PATCH
+    GstStructure *s;
+    s = gst_caps_get_structure (CUR_STREAM (stream)->caps, 0);
+    if (strcmp (gst_structure_get_name (s), "video/x-h265-tcl") == 0 && gst_structure_has_field (s, "codec_data")) {
+      const GValue *val = gst_structure_get_value (s, "codec_data");
+      if (val) {
+        GstBuffer *buf = gst_value_get_buffer (val);
+        GstMapInfo mapinfo;
+        if (gst_buffer_map (buf, &mapinfo, GST_MAP_READ)) {
+          guint8 *data = mapinfo.data;
+          if (data && mapinfo.size > 22 && data[22] > 0) {
+            gst_structure_set_name(s, "video/x-h265");
+            GST_ERROR_OBJECT (qtdemux, "codec_data size:%d, NALUArreyCount:%d, disablelink h265parser", mapinfo.size, data[22]);
+          }
+          gst_buffer_unmap (buf, &mapinfo);
+        }
+      }
+    }
+#endif
+
     if (stream->new_stream) {
       GstEvent *event;
       GstStreamFlags stream_flags = GST_STREAM_FLAG_NONE;
@@ -8926,7 +9273,20 @@ gst_qtdemux_add_stream (GstQTDemux * qtdemux,
       goto done;
     }
 
+#ifdef TCL_PATCH
+    if (qtdemux->video_info->videoCount < MAX_VIDEO_TRACK_NUM) {
+      qtdemux->video_info->videoNodes[qtdemux->n_video_streams].pid = stream->track_id;
+      GST_INFO_OBJECT (qtdemux, "n_video_streams is:%d, trackID: %d    %p",qtdemux->n_video_streams,
+      qtdemux->video_info->videoNodes[qtdemux->n_video_streams].pid, qtdemux->video_info);
+      qtdemux->n_video_streams++;
+      qtdemux->video_info->videoCount = qtdemux->n_video_streams;
+    } else {
+      GST_WARNING_OBJECT(qtdemux, "videoCount(%d) >= MAX_VIDEO_TRACK_NUM(%d)", qtdemux->video_info->videoCount, MAX_VIDEO_TRACK_NUM);
+      qtdemux->n_video_streams++;
+    }
+#else
     qtdemux->n_video_streams++;
+#endif
   } else if (stream->subtype == FOURCC_soun) {
     gchar *name = g_strdup_printf ("audio_%u", qtdemux->n_audio_streams);
 
@@ -8939,7 +9299,22 @@ gst_qtdemux_add_stream (GstQTDemux * qtdemux,
       ret = FALSE;
       goto done;
     }
+#ifdef TCL_PATCH
+    if (qtdemux->audio_info->audioCount < MAX_AUDIO_TRACK_NUM) {
+      qtdemux->audio_info->audioInfoNodes[qtdemux->n_audio_streams].pid = stream->track_id;
+      strcpy(qtdemux->audio_info->audioInfoNodes[qtdemux->n_audio_streams].language, stream->lang_id);
+      GST_INFO_OBJECT (qtdemux, "n_audio_streams is:%d, trackID: %d,lang_code:%s    %p",qtdemux->n_audio_streams,
+          qtdemux->audio_info->audioInfoNodes[qtdemux->n_audio_streams].pid,
+          qtdemux->audio_info->audioInfoNodes[qtdemux->n_audio_streams].language, qtdemux->audio_info);
+      qtdemux->n_audio_streams++;
+      qtdemux->audio_info->audioCount = qtdemux->n_audio_streams;
+    } else {
+      GST_WARNING_OBJECT(qtdemux, "audioCount(%d) >= MAX_AUDIO_TRACK_NUM(%d)", qtdemux->audio_info->audioCount, MAX_AUDIO_TRACK_NUM);
+      qtdemux->n_audio_streams++;
+    }
+#else
     qtdemux->n_audio_streams++;
+#endif
   } else if (stream->subtype == FOURCC_strm) {
     GST_DEBUG_OBJECT (qtdemux, "stream type, not creating pad");
   } else if (stream->subtype == FOURCC_subp || stream->subtype == FOURCC_text
@@ -9307,6 +9682,22 @@ qtdemux_stbl_init (GstQTDemux * qtdemux, QtDemuxStream * stream, GNode * stbl)
         !gst_byte_reader_get_uint32_be (&stream->stss, &stream->n_sample_syncs))
       goto corrupt_file;
 
+#ifdef TCL_PATCH
+    if(stream->n_sample_syncs <= 1)
+    {
+      // qtdemux->seekable = FALSE;
+      GST_INFO_OBJECT (qtdemux, "n_sample_syncs:%d", stream->n_sample_syncs);
+      qtdemux->seekable = FALSE;
+    }
+    //post the seekable msg
+    if(qtdemux->seekable == FALSE)
+    {
+      gst_element_post_message (GST_ELEMENT_CAST (qtdemux),
+        gst_message_new_element (GST_OBJECT_CAST (qtdemux),
+            gst_structure_new ("is-seekable", "is_seekable", G_TYPE_BOOLEAN, qtdemux->seekable, NULL)));
+    }
+#endif
+
     if (stream->n_sample_syncs) {
       /* make sure there's enough data */
       if (!qt_atom_parser_has_chunks (&stream->stss, stream->n_sample_syncs, 4))
@@ -10067,8 +10458,13 @@ qtdemux_parse_segments (GstQTDemux * qtdemux, QtDemuxStream * stream,
     guint32 size;
 
     GST_DEBUG_OBJECT (qtdemux, "looking for edit list");
+#ifdef TCL_PATCH
+    if (1)
+      goto done;
+#else
     if (!(elst = qtdemux_tree_get_child_by_type (edts, FOURCC_elst)))
       goto done;
+#endif
 
     buffer = elst->data;
 
@@ -10969,7 +11365,20 @@ qtdemux_parse_trak (GstQTDemux * qtdemux, GNode * trak)
      * some of those trailers, nowadays, have prologue images that are
      * themselves video tracks as well. I haven't really found a way to
      * identify those yet, except for just looking at their duration. */
+#ifdef TCL_PATCH
+    if (tdur1 != 0 && (tdur2 * 10 / tdur1) < 1) {
+      GST_WARNING_OBJECT (qtdemux,
+          "Track shorter than 10%% (%" G_GUINT64_FORMAT "/%" G_GUINT32_FORMAT
+          " vs. %" G_GUINT64_FORMAT "/%" G_GUINT32_FORMAT ") of the stream "
+          "found, assuming preview image or something; skipping track",
+          stream->duration, stream->timescale, qtdemux->duration,
+          qtdemux->timescale);
+      gst_qtdemux_stream_unref (stream);
+      return TRUE;
+    }
+#else
     if (tdur1 != 0 && (tdur2 * 10 / tdur1) < 2) {
+
       GST_WARNING_OBJECT (qtdemux,
           "Track shorter than 20%% (%" G_GUINT64_FORMAT "/%" G_GUINT32_FORMAT
           " vs. %" G_GUINT64_FORMAT "/%" G_GUINT32_FORMAT ") of the stream "
@@ -10979,6 +11388,7 @@ qtdemux_parse_trak (GstQTDemux * qtdemux, GNode * trak)
       gst_qtdemux_stream_unref (stream);
       return TRUE;
     }
+#endif
   }
 
   if (!(hdlr = qtdemux_tree_get_child_by_type (mdia, FOURCC_hdlr)))
@@ -11454,6 +11864,42 @@ qtdemux_parse_trak (GstQTDemux * qtdemux, GNode * trak)
                   break;
                 }
 
+#ifdef TCL_PATCH
+                case FOURCC_dvcC:
+                case FOURCC_dvvC:
+                case FOURCC_dvwC:
+                {
+                  /* parse, if found */
+                  const guint8 *dv_data = avc_data + 0x8;
+
+                  GST_DEBUG_OBJECT (qtdemux, "found dvcC/dvvC/dvwC codec_data in stsd");
+
+                  /* First 4 bytes are the length of the atom, the next 4 bytes
+                   * are the fourcc, the next 1 byte is the version, and the
+                   * subsequent bytes are sequence parameter set like data. */
+                  guint8 dv_version_major = dv_data[0];
+                  guint8 dv_version_minor = dv_data[1];
+                  guint16 dv_configure = QT_UINT16(dv_data + 2);
+                  guint8 dv_profile = (dv_configure >> 9) & 0x007F;
+                  guint8 dv_level = (dv_configure >> 3) & 0x003F;
+                  guint8 rpu_present_flag = (dv_configure >> 2) & 0x0001;
+                  guint8 el_present_flag = (dv_configure >> 1) & 0x0001;
+                  guint8 bl_present_flag = (dv_configure) & 0x0001;
+                  guint8 dv_bl_signal_compatibility_id = (QT_UINT8(dv_data + 4) >> 4) & 0x0F;
+
+                  gst_caps_set_simple (entry->caps, "is_doblyVision", G_TYPE_BOOLEAN, TRUE,
+                      "dv_version_major", G_TYPE_UINT, dv_version_major,
+                      "dv_version_minor", G_TYPE_UINT, dv_version_minor,
+                      "dv_profile", G_TYPE_UINT, dv_profile,
+                      "dv_level", G_TYPE_UINT, dv_level,
+                      "rpu_present_flag", G_TYPE_UINT, rpu_present_flag,
+                      "el_present_flag", G_TYPE_UINT, el_present_flag,
+                      "bl_present_flag", G_TYPE_UINT, bl_present_flag,
+                      "dv_bl_signal_compatibility_id", G_TYPE_UINT, dv_bl_signal_compatibility_id,
+                      NULL);
+                  break;
+                }
+#endif
                 default:
                   break;
               }
@@ -11510,6 +11956,42 @@ qtdemux_parse_trak (GstQTDemux * qtdemux, GNode * trak)
                   gst_buffer_unref (buf);
                   break;
                 }
+#ifdef TCL_PATCH
+                case FOURCC_dvcC:
+                case FOURCC_dvvC:
+                case FOURCC_dvwC:
+                {
+                  /* parse, if found */
+                  const guint8 *dv_data = hevc_data + 0x8;
+
+                  GST_DEBUG_OBJECT (qtdemux, "found dvcC/dvvC/dvwC codec_data in stsd");
+
+                  /* First 4 bytes are the length of the atom, the next 4 bytes
+                   * are the fourcc, the next 1 byte is the version, and the
+                   * subsequent bytes are sequence parameter set like data. */
+                  guint8 dv_version_major = dv_data[0];
+                  guint8 dv_version_minor = dv_data[1];
+                  guint16 dv_configure = QT_UINT16(dv_data + 2);
+                  guint8 dv_profile = (dv_configure >> 9) & 0x007F;
+                  guint8 dv_level = (dv_configure >> 3) & 0x003F;
+                  guint8 rpu_present_flag = (dv_configure >> 2) & 0x0001;
+                  guint8 el_present_flag = (dv_configure >> 1) & 0x0001;
+                  guint8 bl_present_flag = (dv_configure) & 0x0001;
+                  guint8 dv_bl_signal_compatibility_id = (QT_UINT8(dv_data + 4) >> 4) & 0x0F;
+
+                  gst_caps_set_simple (entry->caps, "is_doblyVision", G_TYPE_BOOLEAN, TRUE,
+                      "dv_version_major", G_TYPE_UINT, dv_version_major,
+                      "dv_version_minor", G_TYPE_UINT, dv_version_minor,
+                      "dv_profile", G_TYPE_UINT, dv_profile,
+                      "dv_level", G_TYPE_UINT, dv_level,
+                      "rpu_present_flag", G_TYPE_UINT, rpu_present_flag,
+                      "el_present_flag", G_TYPE_UINT, el_present_flag,
+                      "bl_present_flag", G_TYPE_UINT, bl_present_flag,
+                      "dv_bl_signal_compatibility_id", G_TYPE_UINT, dv_bl_signal_compatibility_id,
+                      NULL);
+                  break;
+                }
+#endif
                 default:
                   break;
               }
@@ -11892,6 +12374,9 @@ qtdemux_parse_trak (GstQTDemux * qtdemux, GNode * trak)
             gst_buffer_unref (buf);
             break;
           }
+#ifdef TCL_PATCH
+          case GST_MAKE_FOURCC ('W', 'M', 'V', '3'):
+#endif
           case FOURCC_vc_1:
           {
             guint len = QT_UINT32 (stsd_entry_data);
@@ -11914,6 +12399,9 @@ qtdemux_parse_trak (GstQTDemux * qtdemux, GNode * trak)
                 break;
 
               switch (QT_FOURCC (vc1_data + 0x4)) {
+#ifdef TCL_PATCH
+                case GST_MAKE_FOURCC ('g', 'l', 'b', 'l'):
+#endif
                 case GST_MAKE_FOURCC ('d', 'v', 'c', '1'):
                 {
                   GstBuffer *buf;
@@ -11935,6 +12423,10 @@ qtdemux_parse_trak (GstQTDemux * qtdemux, GNode * trak)
             break;
           }
           case FOURCC_av01:
+
+#ifdef TCL_PATCH
+          case FOURCC_dav1:
+#endif
           {
             guint len = QT_UINT32 (stsd_entry_data);
             len = len <= 0x56 ? 0 : len - 0x56;
@@ -12029,6 +12521,43 @@ qtdemux_parse_trak (GstQTDemux * qtdemux, GNode * trak)
 
                   break;
                 }
+
+#ifdef TCL_PATCH
+                case FOURCC_dvcC:
+                case FOURCC_dvvC:
+                case FOURCC_dvwC:
+                {
+                  /* parse, if found */
+                  const guint8 *dv_data = av1_data + 0x8;
+
+                  GST_DEBUG_OBJECT (qtdemux, "found dvcC/dvvC/dvwC codec_data in stsd");
+
+                  /* First 4 bytes are the length of the atom, the next 4 bytes
+                   * are the fourcc, the next 1 byte is the version, and the
+                   * subsequent bytes are sequence parameter set like data. */
+                  guint8 dv_version_major = dv_data[0];
+                  guint8 dv_version_minor = dv_data[1];
+                  guint16 dv_configure = QT_UINT16(dv_data + 2);
+                  guint8 dv_profile = (dv_configure >> 9) & 0x007F;
+                  guint8 dv_level = (dv_configure >> 3) & 0x003F;
+                  guint8 rpu_present_flag = (dv_configure >> 2) & 0x0001;
+                  guint8 el_present_flag = (dv_configure >> 1) & 0x0001;
+                  guint8 bl_present_flag = (dv_configure) & 0x0001;
+                  guint8 dv_bl_signal_compatibility_id = (QT_UINT8(dv_data + 4) >> 4) & 0x0F;
+
+                  gst_caps_set_simple (entry->caps, "is_doblyVision", G_TYPE_BOOLEAN, TRUE,
+                      "dv_version_major", G_TYPE_UINT, dv_version_major,
+                      "dv_version_minor", G_TYPE_UINT, dv_version_minor,
+                      "dv_profile", G_TYPE_UINT, dv_profile,
+                      "dv_level", G_TYPE_UINT, dv_level,
+                      "rpu_present_flag", G_TYPE_UINT, rpu_present_flag,
+                      "el_present_flag", G_TYPE_UINT, el_present_flag,
+                      "bl_present_flag", G_TYPE_UINT, bl_present_flag,
+                      "dv_bl_signal_compatibility_id", G_TYPE_UINT, dv_bl_signal_compatibility_id,
+                      NULL);
+                  break;
+                }
+#endif
                 default:
                   break;
               }
@@ -12197,6 +12726,16 @@ qtdemux_parse_trak (GstQTDemux * qtdemux, GNode * trak)
         }
       }
 
+#ifdef TCL_PATCH
+      gchar *rotation = NULL;
+      gst_tag_list_get_string (stream->stream_tags, GST_TAG_IMAGE_ORIENTATION, &rotation);
+      if (rotation != NULL) {
+        GST_INFO_OBJECT (qtdemux, "rotation:%s", rotation);
+        gst_caps_set_simple (entry->caps, "rotation", G_TYPE_STRING, rotation, NULL);
+        g_free (rotation);
+      }
+#endif
+
       GST_INFO_OBJECT (qtdemux,
           "type %" GST_FOURCC_FORMAT " caps %" GST_PTR_FORMAT,
           GST_FOURCC_ARGS (fourcc), entry->caps);
@@ -12637,6 +13176,11 @@ qtdemux_parse_trak (GstQTDemux * qtdemux, GNode * trak)
           guint8 coupled_count;
           guint8 i;
 
+#ifdef TCL_PATCH
+          guint16 pre_skip;
+          guint8 *extradata;
+          guint32 extradataSize;
+#endif
           version = GST_READ_UINT16_BE (stsd_entry_data + 16);
           if (version == 1)
             dops_data = stsd_entry_data + 51;
@@ -12658,7 +13202,69 @@ qtdemux_parse_trak (GstQTDemux * qtdemux, GNode * trak)
           entry->caps = gst_codec_utils_opus_create_caps (rate, channels,
               channel_mapping_family, stream_count, coupled_count,
               channel_mapping);
+
+#ifdef TCL_PATCH
+          // 开始 Extradata (CSD) 组合
+          const int OPUS_SEEK_PREROLL_MS = 80;
+          // 计算 extradata 的大小：OpusHead（大小 19）+ channel_mapping（如果有）
+          // 注意：根据具体需求和 OpusHead 结构调整大小
+          extradataSize = 19 + (channels > 0 ? channels : 0);
+          extradata = g_malloc(extradataSize);
+          if (!extradata) {
+              GST_ERROR("Failed to allocate memory for extradata");
+              g_free (channel_mapping);
+              return GST_FLOW_ERROR;
+          }
+
+          // 构建 OpusHead 结构
+          memcpy(extradata, "OpusHead", 8);
+          // 版本
+          extradata[8] = 1;
+          // 声道数
+          extradata[9] = channels;
+        // 预跳过（示例值，根据需求调整）
+          pre_skip = 0; // 可以根据需要设置
+          extradata[10] = pre_skip & 0xFF;
+          extradata[11] = (pre_skip >> 8) & 0xFF;
+          // 输入采样率（小端）
+          extradata[12] = rate & 0xFF;
+          extradata[13] = (rate >> 8) & 0xFF;
+          extradata[14] = (rate >> 16) & 0xFF;
+          extradata[15] = (rate >> 24) & 0xFF;
+          // 输出增益（小端），设置为 0
+          extradata[16] = 0;
+          extradata[17] = 0;
+          // 声道映射家族
+          extradata[18] = channel_mapping_family;
+
+          // 如果有声道映射，则追加到 extradata
+          if (channels > 0 && channel_mapping) {
+              memcpy(extradata + 19, channel_mapping, channels);
+          }
+
+          GstBuffer *buf;
+          buf = gst_buffer_new_and_alloc (extradataSize);
+          gst_buffer_fill (buf, 0, extradata,extradataSize);
+
+          GValue array = G_VALUE_INIT;
+          GValue value = G_VALUE_INIT;
+          g_value_init (&array, GST_TYPE_ARRAY);
+          g_value_init (&value, GST_TYPE_BUFFER);
+
+          gst_value_set_buffer (&value, buf);
+          gst_value_array_append_value (&array, &value);
+          gst_structure_set_value (gst_caps_get_structure (entry->caps, 0), "streamheader", &array);
+
+          g_value_reset (&value);
+          gst_buffer_unref (buf);
+          g_value_unset (&value);
+          g_value_unset (&array);
+          g_free (channel_mapping);
+          g_free(extradata);
+    // Extradata (CSD) 组合结束
+#else
           g_free (channel_mapping);
+#endif
           break;
         }
         default:
@@ -13061,6 +13667,23 @@ qtdemux_parse_trak (GstQTDemux * qtdemux, GNode * trak)
         {
           GNode *mp4s = NULL;
           GNode *esds = NULL;
+#ifdef TCL_PATCH
+          gint8  skip = tkhd.size - tkhd.byte;
+          /* 取最后8字节来获取width & height*/
+          if(skip >= 8 && gst_byte_reader_skip(&tkhd, skip - 8))
+          {
+              guint32 w = 0, h = 0;
+              if(gst_byte_reader_get_uint32_be(&tkhd, &w) && gst_byte_reader_get_uint32_be(&tkhd, &h))
+              {
+                  stream->display_width  = w >> 16;
+                  stream->display_height = h >> 16;
+                  if(entry->caps)
+                  {
+                      gst_caps_set_simple(entry->caps, "vobsub_width", G_TYPE_UINT, stream->display_width, "vobsub_height", G_TYPE_UINT, stream->display_height, NULL);
+                  }
+              }
+          }
+#endif
 
           /* look for palette in a stsd->mp4s->esds sub-atom */
           mp4s = qtdemux_tree_get_child_by_type (stsd, FOURCC_mp4s);
@@ -13158,9 +13781,14 @@ qtdemux_parse_trak (GstQTDemux * qtdemux, GNode * trak)
     const gchar *lang_code;
 
     /* convert ISO 639-2 code to ISO 639-1 */
+#ifndef TCL_PATCH
     lang_code = gst_tag_get_language_code (stream->lang_id);
     gst_tag_list_add (stream->stream_tags, GST_TAG_MERGE_REPLACE,
         GST_TAG_LANGUAGE_CODE, (lang_code) ? lang_code : stream->lang_id, NULL);
+#else
+    gst_tag_list_add (stream->stream_tags, GST_TAG_MERGE_REPLACE,
+        GST_TAG_LANGUAGE_CODE, stream->lang_id, NULL);
+#endif
   }
 
   /* Check for UDTA tags */
@@ -13482,6 +14110,9 @@ static GstFlowReturn
 qtdemux_expose_streams (GstQTDemux * qtdemux)
 {
   gint i;
+#ifdef TCL_PATCH
+  guint32 tmp_timescale = 0;
+#endif
 
   GST_DEBUG_OBJECT (qtdemux, "exposing streams");
 
@@ -13511,6 +14142,10 @@ qtdemux_expose_streams (GstQTDemux * qtdemux)
       /* now we have all info and can expose */
       list = stream->stream_tags;
       stream->stream_tags = NULL;
+#ifdef TCL_PATCH
+      if(stream->timescale)
+        tmp_timescale = stream->timescale;
+#endif
       if (!gst_qtdemux_add_stream (qtdemux, stream, list))
         return GST_FLOW_ERROR;
 
@@ -13538,6 +14173,18 @@ qtdemux_expose_streams (GstQTDemux * qtdemux)
 
   g_ptr_array_set_size (qtdemux->old_streams, 0);
 
+#ifdef TCL_PATCH
+  /*post a audio info and can expose*/
+  GstStructure *st;
+  st = gst_structure_new ("qtdemux-media-info",
+           "timescale",G_TYPE_INT,(tmp_timescale) ? tmp_timescale : qtdemux->timescale,
+           "audio-info", G_TYPE_POINTER,qtdemux->audio_info,
+           "video-info", G_TYPE_POINTER,qtdemux->video_info,
+           NULL);
+  gst_element_post_message (GST_ELEMENT_CAST(qtdemux),
+  gst_message_new_element (GST_OBJECT(qtdemux), st));
+#endif
+
   /* check if we should post a redirect in case there is a single trak
    * and it is a redirecting trak */
   if (QTDEMUX_N_STREAMS (qtdemux) == 1 &&
@@ -14320,6 +14967,14 @@ gst_qtdemux_handle_esds (GstQTDemux * qtdemux, QtDemuxStream * stream,
 
   /* If we have a replacement caps, then change our caps for this stream */
   if (caps) {
+#ifdef TCL_PATCH
+    GstStructure *st = gst_caps_get_structure (caps, 0);
+    const gchar* name = gst_structure_get_name(st);
+    if (name && !strstr(name, "audio") && codec_name && list) {
+      gst_tag_list_add (list, GST_TAG_MERGE_REPLACE,
+          GST_TAG_VIDEO_CODEC, codec_name, NULL);
+    }
+#endif
     gst_caps_unref (entry->caps);
     entry->caps = caps;
   }
@@ -14483,6 +15138,9 @@ qtdemux_video_caps (GstQTDemux * qtdemux, QtDemuxStream * stream,
        format = GST_VIDEO_FORMAT_v408;
        break;
        */
+#ifdef TCL_PATCH
+    case GST_MAKE_FOURCC ('m','1','v',' '):
+#endif
     case GST_MAKE_FOURCC ('m', 'p', 'e', 'g'):
     case GST_MAKE_FOURCC ('m', 'p', 'g', '1'):
       _codec ("MPEG-1 video");
@@ -14631,16 +15289,28 @@ qtdemux_video_caps (GstQTDemux * qtdemux, QtDemuxStream * stream,
     case FOURCC_hvc1:
     case FOURCC_dvh1:
       _codec ("H.265 / HEVC");
+#ifdef TCL_PATCH
+      caps = gst_caps_new_simple ("video/x-h265-tcl",
+          "stream-format", G_TYPE_STRING, "hvc1",
+          "alignment", G_TYPE_STRING, "au", NULL);
+#else
       caps = gst_caps_new_simple ("video/x-h265",
           "stream-format", G_TYPE_STRING, "hvc1",
           "alignment", G_TYPE_STRING, "au", NULL);
+#endif
       break;
     case FOURCC_hev1:
     case FOURCC_dvhe:
       _codec ("H.265 / HEVC");
+#ifdef TCL_PATCH
+      caps = gst_caps_new_simple ("video/x-h265-tcl",
+          "stream-format", G_TYPE_STRING, "hvc1",
+          "alignment", G_TYPE_STRING, "au", NULL);
+#else
       caps = gst_caps_new_simple ("video/x-h265",
           "stream-format", G_TYPE_STRING, "hev1",
           "alignment", G_TYPE_STRING, "au", NULL);
+#endif
       break;
     case FOURCC_rle_:
       _codec ("Run-length encoding");
@@ -14790,11 +15460,27 @@ qtdemux_video_caps (GstQTDemux * qtdemux, QtDemuxStream * stream,
       caps = gst_caps_new_simple ("video/x-wmv",
           "wmvversion", G_TYPE_INT, 3, "format", G_TYPE_STRING, "WVC1", NULL);
       break;
+#ifdef TCL_PATCH
+    case GST_MAKE_FOURCC ('W', 'M', 'V', '3'):
+      _codec ("VC-1");
+      caps = gst_caps_new_simple ("video/x-wmv",
+          "wmvversion", G_TYPE_INT, 3, "format", G_TYPE_STRING, "WMV3", NULL);
+      break;
+#endif
     case FOURCC_av01:
+#ifdef TCL_PATCH
+    case FOURCC_dav1:
+#endif
       _codec ("AV1");
+#ifdef TCL_PATCH
+      caps = gst_caps_new_simple ("video/x-av1-tcl",
+          "stream-format", G_TYPE_STRING, "obu-stream",
+          "alignment", G_TYPE_STRING, "tu", NULL);
+#else
       caps = gst_caps_new_simple ("video/x-av1",
           "stream-format", G_TYPE_STRING, "obu-stream",
           "alignment", G_TYPE_STRING, "tu", NULL);
+#endif
       break;
     case GST_MAKE_FOURCC ('k', 'p', 'c', 'd'):
     default:
@@ -14833,6 +15519,108 @@ round_up_pow2 (guint n)
   return n + 1;
 }
 
+#ifdef TCL_PATCH
+#include "android/log.h"
+void android_log_callback(void* ptr, int level, const char* fmt, va_list vl) {
+    char message[1024];
+    vsnprintf(message, sizeof(message), fmt, vl);
+
+    // 根据 FFmpeg 的日志级别映射到 Android 的日志级别
+    int androidLevel;
+    switch (level) {
+        case AV_LOG_PANIC:
+        case AV_LOG_FATAL:
+            androidLevel = ANDROID_LOG_FATAL;
+            break;
+        case AV_LOG_ERROR:
+            androidLevel = ANDROID_LOG_ERROR;
+            break;
+        case AV_LOG_WARNING:
+            androidLevel = ANDROID_LOG_WARN;
+            break;
+        case AV_LOG_INFO:
+            androidLevel = ANDROID_LOG_INFO;
+            break;
+        case AV_LOG_DEBUG:
+        case AV_LOG_VERBOSE:
+            androidLevel = ANDROID_LOG_DEBUG;
+            break;
+        default:
+            androidLevel = ANDROID_LOG_UNKNOWN;
+            break;
+    }
+
+    __android_log_print(androidLevel, "FFmpeg", "%s", message);
+}
+
+static void ffmpeg_fun(GstQTDemux * qtdemux, int type, int *channels, int *sample_rate, int *bit_rate) {
+    GstQuery *query;
+    gchar *uri = NULL;
+    AVFormatContext *context;
+    AVIOContext *iocontext = NULL;
+    int res,i;
+
+    //register ffmpeg callback
+    //av_log_set_callback(android_log_callback);
+
+    res = gst_ffmpegdata_open (qtdemux->sinkpad, AVIO_FLAG_READ, &iocontext);
+
+    query = gst_query_new_uri ();
+    if (gst_pad_peer_query (qtdemux->sinkpad, query)) {
+      gchar *query_uri, *redirect_uri;
+      gboolean permanent;
+
+      gst_query_parse_uri (query, &query_uri);
+      gst_query_parse_uri_redirection (query, &redirect_uri);
+      gst_query_parse_uri_redirection_permanent (query, &permanent);
+
+      if (permanent && redirect_uri) {
+        uri = redirect_uri;
+        g_free (query_uri);
+      } else {
+        uri = query_uri;
+        g_free (redirect_uri);
+      }
+    }
+    gst_query_unref (query);
+    GST_ERROR_OBJECT (qtdemux, "Opening context with URI %s", GST_STR_NULL (uri));
+
+    context = avformat_alloc_context ();
+    if (!context) {
+        GST_ERROR("avformat_alloc_context failed!!!");
+        goto done;
+    }
+    context->pb = iocontext;
+    res = avformat_open_input (&context, uri, NULL, NULL);
+    if (res < 0) {
+        GST_ERROR("avformat_open_input failed!!!");
+        goto done;
+    }
+    GST_ERROR("nb_streams = %d", context->nb_streams);
+
+    res = avformat_find_stream_info (context, NULL);
+    for (i = 0; i < context->nb_streams; i++) {
+        if (context->streams[i]->codecpar->codec_id == type) {
+            GST_ERROR("type = %d, channels = %d sample_rate = %d bit_rate = %lld",
+                type, context->streams[i]->codecpar->channels, context->streams[i]->codecpar->sample_rate, context->streams[i]->codecpar->bit_rate);
+            *channels = context->streams[i]->codecpar->channels;
+            *sample_rate = context->streams[i]->codecpar->sample_rate;
+            *bit_rate = context->streams[i]->codecpar->bit_rate;
+        }
+    }
+
+done:
+    g_free (uri);
+    gst_ffmpegdata_close (iocontext);
+//    gst_ffmpeg_pipe_close (iocontext);
+    iocontext = NULL;
+    avformat_close_input (&context);
+    if (context)
+      avformat_free_context (context);
+    context = NULL;
+}
+#endif
+
 static GstCaps *
 qtdemux_audio_caps (GstQTDemux * qtdemux, QtDemuxStream * stream,
     QtDemuxStreamStsdEntry * entry, guint32 fourcc, const guint8 * data,
@@ -14969,16 +15757,27 @@ qtdemux_audio_caps (GstQTDemux * qtdemux, QtDemuxStream * stream,
       break;
     case 0x20736d:
     case GST_MAKE_FOURCC ('e', 'c', '-', '3'):
+#ifdef TCL_PATCH
+      _codec ("E-AC3");
+      caps = gst_caps_new_empty_simple ("audio/x-eac3");
+#else
       _codec ("EAC-3 audio");
       caps = gst_caps_new_simple ("audio/x-eac3",
           "framed", G_TYPE_BOOLEAN, TRUE, NULL);
+#endif
       entry->sampled = TRUE;
       break;
     case GST_MAKE_FOURCC ('s', 'a', 'c', '3'): // Nero Recode
     case FOURCC_ac_3:
+#ifdef TCL_PATCH
+      _codec ("AC-3");
+      caps = gst_caps_new_empty_simple ("audio/x-ac3");
+#else
       _codec ("AC-3 audio");
       caps = gst_caps_new_simple ("audio/x-ac3",
           "framed", G_TYPE_BOOLEAN, TRUE, NULL);
+#endif
+
       entry->sampled = TRUE;
       break;
     case GST_MAKE_FOURCC ('d', 't', 's', 'c'):
@@ -14995,6 +15794,14 @@ qtdemux_audio_caps (GstQTDemux * qtdemux, QtDemuxStream * stream,
           "framed", G_TYPE_BOOLEAN, TRUE, NULL);
       entry->sampled = TRUE;
       break;
+    case GST_MAKE_FOURCC ('d','t','s','e'):
+      entry->sampled = TRUE;
+      caps = _get_unknown_codec_name ("audio", fourcc);
+      break;
+    case GST_MAKE_FOURCC ('d','t','s','x'):
+      entry->sampled = TRUE;
+      caps = _get_unknown_codec_name ("audio", fourcc);
+      break;
     case FOURCC_MAC3:
       _codec ("MACE-3");
       caps = gst_caps_new_simple ("audio/x-mace",
@@ -15014,10 +15821,30 @@ qtdemux_audio_caps (GstQTDemux * qtdemux, QtDemuxStream * stream,
       caps = gst_caps_new_empty_simple ("audio/x-dv");
       break;
     case FOURCC_mp4a:
+#ifdef TCL_PATCH
+      _codec ("HEAAC");
+      caps = gst_caps_new_simple ("audio/mpeg",
+          "mpegversion", G_TYPE_INT, 4, "framed", G_TYPE_BOOLEAN, FALSE,
+          "codec_set", G_TYPE_BOOLEAN, TRUE,
+          "stream-format", G_TYPE_STRING, "raw", NULL);
+      gint64 val;
+      gst_pad_peer_query_duration (qtdemux->sinkpad, GST_FORMAT_BYTES, &val);
+      GST_ERROR("ffmpeg_fun size = %lld", val);
+      if (val < 600000000) {
+          int channels = 0, sample_rate = 0, bit_rate =0;
+          ffmpeg_fun(qtdemux, AV_CODEC_ID_AAC, &channels, &sample_rate, &bit_rate);
+          gst_caps_set_simple (caps, "bitrate", G_TYPE_INT, bit_rate, "from qtdemux", G_TYPE_BOOLEAN, TRUE, NULL);
+      } else {
+          GST_ERROR("size > 600000000, do not ffmpeg_fun");
+      }
+
+#else
       _codec ("MPEG-4 AAC audio");
       caps = gst_caps_new_simple ("audio/mpeg",
           "mpegversion", G_TYPE_INT, 4, "framed", G_TYPE_BOOLEAN, TRUE,
           "stream-format", G_TYPE_STRING, "raw", NULL);
+
+#endif
       break;
     case GST_MAKE_FOURCC ('Q', 'D', 'M', 'C'):
       _codec ("QDesign Music");
@@ -15141,7 +15968,14 @@ qtdemux_audio_caps (GstQTDemux * qtdemux, QtDemuxStream * stream,
     case GST_MAKE_FOURCC ('a', 'c', '-', '4'):
     {
       _codec ("AC4");
+#ifdef TCL_PATCH
+      caps = gst_caps_new_simple ("audio/x-ac4",
+          "framed", G_TYPE_BOOLEAN, TRUE, NULL);
+      entry->sampled = TRUE;
+#else
       caps = gst_caps_new_empty_simple ("audio/x-ac4");
+#endif
+
       break;
     }
     case GST_MAKE_FOURCC ('q', 't', 'v', 'r'):
@@ -15286,3 +16120,25 @@ gst_qtdemux_append_protection_system_id (GstQTDemux * qtdemux,
   g_ptr_array_add (qtdemux->protection_system_ids, g_ascii_strdown (system_id,
           -1));
 }
+
+#ifdef TCL_PATCH
+static void
+gst_qtdemux_demux_remove_pad(GstElement *element, GstPad *pad)
+{
+    GstQTDemux *demux  =  GST_QTDEMUX (element);
+    GST_OBJECT_LOCK (element);
+    int i = 0;
+    QtDemuxStream *stream = NULL;
+    for (; i < demux->active_streams->len; i++)
+    {
+        stream = (QtDemuxStream *)demux->active_streams->pdata[i];
+        if(stream->pad == pad)
+            break;
+    }
+    GST_OBJECT_UNLOCK (element);
+    if(i < demux->active_streams->len)
+        gst_qtdemux_stream_unref(stream);
+    else
+        GST_ERROR_OBJECT (demux, "Can Not Remove Designated Pad Because of Can Not Finding it!!");
+}
+#endif
diff --git a/subprojects/gst-plugins-good/gst/isomp4/qtdemux.h b/subprojects/gst-plugins-good/gst/isomp4/qtdemux.h
index 7e9e7c6201..02ef5c8cbe 100644
--- a/subprojects/gst-plugins-good/gst/isomp4/qtdemux.h
+++ b/subprojects/gst-plugins-good/gst/isomp4/qtdemux.h
@@ -78,6 +78,88 @@ typedef enum {
   VARIANT_MSS_FRAGMENTED,
 } Variant;
 
+#ifdef TCL_PATCH
+
+#define MAX_STREAMS_NUM (30)
+
+#define UNIMP_STRING_LEN_4          4
+#define UNIMP_STRING_LEN_8          8
+#define UNIMP_STRING_LEN_10         10
+#define UNIMP_STRING_LEN_16         16
+#define UNIMP_STRING_LEN_32         32
+#define UNIMP_STRING_LEN_128        128
+#define UNIMP_STRING_LEN_256        256
+#define UNIMP_STRING_LEN_512        512
+#define UNIMP_STRING_LEN_1024       1024
+
+#define MAX_VIDEO_TRACK_NUM         8
+#define MAX_AUDIO_TRACK_NUM         32
+#define MAX_SUBTITLE_TRACK_NUM      8
+
+typedef struct
+{
+  int32_t pid;
+  int8_t encoding[UNIMP_STRING_LEN_32];
+  int8_t mime[UNIMP_STRING_LEN_32];
+  int32_t componentTag;
+  int32_t encrypted;
+  int8_t language[UNIMP_STRING_LEN_4];
+  int32_t audioDescription;
+  int32_t selectionPriority;
+  int32_t audioChannels;
+  int32_t preselectionId[UNIMP_STRING_LEN_10];
+  int32_t preselectionTag[UNIMP_STRING_LEN_10];
+  int8_t  preselectionLang[UNIMP_STRING_LEN_10][UNIMP_STRING_LEN_4];
+  int32_t preselectionCount;
+  uint8_t name[UNIMP_STRING_LEN_128];
+  uint32_t bitRate;
+  int32_t sampleRate;
+} media_audio_info_node_s;
+
+typedef struct
+{
+  int32_t audioCount;
+  media_audio_info_node_s audioInfoNodes[MAX_AUDIO_TRACK_NUM];
+} media_audio_info_s;
+
+typedef struct
+{
+  int32_t programNumber;
+  media_audio_info_s *audioInfo;
+} media_audio_extend_info_s;
+
+typedef struct
+{
+  int32_t programCount;
+  media_audio_extend_info_s *audioExtendInfos[MAX_AUDIO_TRACK_NUM];
+} media_audio_info_list_s;
+
+typedef struct
+{
+  int32_t pid;
+  int8_t encoding[UNIMP_STRING_LEN_32];
+  int8_t mime[UNIMP_STRING_LEN_32];
+  int32_t componentTag;
+  int32_t encrypted;
+  float aspectRatio;
+  int32_t videoDescription;
+  int32_t frames;
+  int32_t time;
+  uint8_t name[UNIMP_STRING_LEN_128];
+  uint8_t language[UNIMP_STRING_LEN_4];
+  int32_t bitRate;
+} media_video_info_node_s;
+
+typedef struct
+{
+  int32_t videoCount;
+  u_int32_t maxWidth;
+  u_int32_t maxHeight;
+  u_int32_t isAdaptive;
+  media_video_info_node_s videoNodes[MAX_VIDEO_TRACK_NUM];
+} media_video_info_s;
+#endif
+
 struct _GstQTDemux {
   GstElement element;
 
@@ -180,6 +262,17 @@ struct _GstQTDemux {
   guint32 cenc_aux_sample_count;
   gchar *preferred_protection_system_id;
 
+#ifdef TCL_PATCH
+  /*total audio info collect*/
+  media_audio_info_s * audio_info;
+
+  /*total video info collect*/
+  media_video_info_s * video_info;
+
+  guint64 latest_pushed_buffer_pts;
+  gboolean seekable;//whether has key frames
+#endif
+
   /* Whether the parent bin is streams-aware, meaning we can
    * add/remove streams at any point in time */
   gboolean streams_aware;
@@ -245,6 +338,9 @@ struct _GstQTDemux {
   gint index_id;
 #endif
 
+#ifdef TCL_PATCH
+  gboolean hasHevc;
+#endif
   /* Whether upstream is seekable in BYTES */
   gboolean upstream_seekable;
   /* UPSTREAM BYTE: Size of upstream content.
@@ -522,6 +618,9 @@ struct _QtDemuxStream
   GstClockTime last_keyframe_dts;
 
   gint ref_count;               /* atomic */
+#ifdef TCL_PATCH
+  gint32 pts_shift;             /* for caculate pts */
+#endif
 };
 
 G_END_DECLS
diff --git a/subprojects/gst-plugins-good/gst/isomp4/qtdemux_types.c b/subprojects/gst-plugins-good/gst/isomp4/qtdemux_types.c
index a78415a065..bef0f8bbd3 100644
--- a/subprojects/gst-plugins-good/gst/isomp4/qtdemux_types.c
+++ b/subprojects/gst-plugins-good/gst/isomp4/qtdemux_types.c
@@ -222,6 +222,9 @@ static const QtNodeType qt_node_types[] = {
   {FOURCC_wvtt, "WebVTT subtitle sample entry", 0},
   {FOURCC_clcp, "Closed Caption", 0},
   {FOURCC_av01, "AV1 Sample Entry", 0},
+#ifdef TCL_PATCH
+  {FOURCC_dav1, "AV1-based Dolby Vision derived from av01", 0},
+#endif
   {FOURCC_av1C, "AV1 Codec Configuration", 0},
   {FOURCC_av1f, "AV1 Forward Key Frame sample group entry", 0},
   {FOURCC_av1m, "AV1 Multi-Frame sample group entry", 0},
diff --git a/subprojects/gst-plugins-good/gst/matroska/matroska-demux.c b/subprojects/gst-plugins-good/gst/matroska/matroska-demux.c
index f92682358a..6fc1dbe4dd 100644
--- a/subprojects/gst-plugins-good/gst/matroska/matroska-demux.c
+++ b/subprojects/gst-plugins-good/gst/matroska/matroska-demux.c
@@ -70,6 +70,9 @@
 #include "gstmatroskaelements.h"
 #include "matroska-demux.h"
 #include "matroska-ids.h"
+#ifdef TCL_PATCH
+#include <sys/system_properties.h>
+#endif
 
 GST_DEBUG_CATEGORY_STATIC (matroskademux_debug);
 #define GST_CAT_DEFAULT matroskademux_debug
@@ -88,10 +91,18 @@ enum
   PROP_METADATA,
   PROP_STREAMINFO,
   PROP_MAX_GAP_TIME,
-  PROP_MAX_BACKTRACK_DISTANCE
+  PROP_MAX_BACKTRACK_DISTANCE,
+
+#ifdef TCL_PATCH
+  PROP_SEEKABLE,
+  PROP_SUB_GAP_TIME,
+#endif
 };
 
 #define DEFAULT_MAX_GAP_TIME           (2 * GST_SECOND)
+#ifdef TCL_PATCH
+#define DEFAULT_SUB_GAP_TIME           (GST_SECOND / 2)
+#endif
 #define DEFAULT_MAX_BACKTRACK_DISTANCE 30
 #define INVALID_DATA_THRESHOLD         (2 * 1024 * 1024)
 
@@ -175,9 +186,15 @@ static GstIndex *gst_matroska_demux_get_index (GstElement * element);
 static GstCaps *gst_matroska_demux_video_caps (GstMatroskaTrackVideoContext
     * videocontext, const gchar * codec_id, guint8 * data, guint size,
     gchar ** codec_name, guint32 * riff_fourcc);
+#ifdef TCL_PATCH
+static GstCaps *gst_matroska_demux_audio_caps (GstMatroskaDemux * demux, GstMatroskaTrackAudioContext
+    * audiocontext, const gchar * codec_id, guint8 * data, guint size,
+    gchar ** codec_name, guint16 * riff_audio_fmt, GstClockTime * lead_in_ts);
+#else
 static GstCaps *gst_matroska_demux_audio_caps (GstMatroskaTrackAudioContext
     * audiocontext, const gchar * codec_id, guint8 * data, guint size,
     gchar ** codec_name, guint16 * riff_audio_fmt, GstClockTime * lead_in_ts);
+#endif
 static GstCaps
     * gst_matroska_demux_subtitle_caps (GstMatroskaTrackSubtitleContext *
     subtitlecontext, const gchar * codec_id, gpointer data, guint size);
@@ -195,6 +212,9 @@ static void gst_matroska_demux_set_property (GObject * object,
     guint prop_id, const GValue * value, GParamSpec * pspec);
 static void gst_matroska_demux_get_property (GObject * object,
     guint prop_id, GValue * value, GParamSpec * pspec);
+#ifdef TCL_PATCH
+static void gst_matroska_demux_demux_remove_pad(GstElement * element, GstPad * pad);
+#endif
 
 GType gst_matroska_demux_get_type (void);
 #define parent_class gst_matroska_demux_parent_class
@@ -239,6 +259,14 @@ gst_matroska_demux_class_init (GstMatroskaDemuxClass * klass)
           "gaps longer than this (0 = disabled).", 0, G_MAXUINT64,
           DEFAULT_MAX_GAP_TIME, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 
+#ifdef TCL_PATCH
+  g_object_class_install_property (gobject_class, PROP_SUB_GAP_TIME,
+      g_param_spec_uint64 ("sub-gap-time", "sub gap time",
+          "The demuxer sends out segment events for skipping "
+          "gaps longer than this (0 = disabled).", 0, G_MAXUINT64,
+          DEFAULT_SUB_GAP_TIME, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+#endif
+
   g_object_class_install_property (gobject_class, PROP_MAX_BACKTRACK_DISTANCE,
       g_param_spec_uint ("max-backtrack-distance",
           "Maximum backtrack distance",
@@ -248,12 +276,24 @@ gst_matroska_demux_class_init (GstMatroskaDemuxClass * klass)
           0, G_MAXUINT, DEFAULT_MAX_BACKTRACK_DISTANCE,
           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 
+#ifdef TCL_PATCH
+  g_object_class_install_property (gobject_class, PROP_SEEKABLE,
+      g_param_spec_boolean ("is-seekable",
+          "seekable by keyframe",
+          "when there is no keyframe, it is not seekable",
+          FALSE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+#endif
+
   gstelement_class->change_state =
       GST_DEBUG_FUNCPTR (gst_matroska_demux_change_state);
   gstelement_class->send_event =
       GST_DEBUG_FUNCPTR (gst_matroska_demux_element_send_event);
   gstelement_class->query =
       GST_DEBUG_FUNCPTR (gst_matroska_demux_element_query);
+
+#ifdef TCL_PATCH
+  //  gstelement_class->demux_remove_pad= GST_DEBUG_FUNCPTR (gst_matroska_demux_demux_remove_pad);
+#endif
 #if 0
   gstelement_class->set_index =
       GST_DEBUG_FUNCPTR (gst_matroska_demux_set_index);
@@ -299,6 +339,14 @@ gst_matroska_demux_init (GstMatroskaDemux * demux)
   demux->max_gap_time = DEFAULT_MAX_GAP_TIME;
   demux->max_backtrack_distance = DEFAULT_MAX_BACKTRACK_DISTANCE;
 
+#ifdef TCL_PATCH
+  demux->sub_gap_time = GST_SECOND / 2;;
+  demux->file_size = -1;
+  memset(demux->platform_val, 0, 128);
+  __system_property_get("ro.hardware.version_id", demux->platform_val);
+  GST_INFO ("ro.hardware.version_id = %s", demux->platform_val);
+#endif
+
   GST_OBJECT_FLAG_SET (demux, GST_ELEMENT_FLAG_INDEXABLE);
 
   demux->flowcombiner = gst_flow_combiner_new ();
@@ -526,6 +574,44 @@ gst_matroska_demux_parse_mastering_metadata (GstMatroskaDemux * demux,
     }
 
     switch (id) {
+
+// follow by android extractor MatroskaExtractor::getColorInformation()
+#ifdef TCL_PATCH
+      case GST_MATROSKA_ID_PRIMARYRCHROMATICITYX:
+        minfo.display_primaries[0].x = (guint16) (num * chroma_scale + 0.5);
+        break;
+      case GST_MATROSKA_ID_PRIMARYRCHROMATICITYY:
+        minfo.display_primaries[0].y = (guint16) (num * chroma_scale + 0.5);
+        break;
+      case GST_MATROSKA_ID_PRIMARYGCHROMATICITYX:
+        minfo.display_primaries[1].x = (guint16) (num * chroma_scale + 0.5);
+        break;
+      case GST_MATROSKA_ID_PRIMARYGCHROMATICITYY:
+        minfo.display_primaries[1].y = (guint16) (num * chroma_scale + 0.5);
+        break;
+      case GST_MATROSKA_ID_PRIMARYBCHROMATICITYX:
+        minfo.display_primaries[2].x = (guint16) (num * chroma_scale + 0.5);
+        break;
+      case GST_MATROSKA_ID_PRIMARYBCHROMATICITYY:
+        minfo.display_primaries[2].y = (guint16) (num * chroma_scale + 0.5);
+        break;
+      case GST_MATROSKA_ID_WHITEPOINTCHROMATICITYX:
+        minfo.white_point.x = (guint16) (num * chroma_scale + 0.5);
+        break;
+      case GST_MATROSKA_ID_WHITEPOINTCHROMATICITYY:
+        minfo.white_point.y = (guint16) (num * chroma_scale + 0.5);
+        break;
+      case GST_MATROSKA_ID_LUMINANCEMAX:
+        if (num >= 0.5 && num < 65535.5) {
+            minfo.max_display_mastering_luminance = (guint32) (num + 0.5);
+        }
+        break;
+      case GST_MATROSKA_ID_LUMINANCEMIN:
+        if (num >= 0.00005 && num < 6.55355) {
+            minfo.min_display_mastering_luminance = (guint32) (num * luma_scale + 0.5);
+        }
+        break;
+#else
       case GST_MATROSKA_ID_PRIMARYRCHROMATICITYX:
         minfo.display_primaries[0].x = (guint16) (num * chroma_scale);
         break;
@@ -556,6 +642,7 @@ gst_matroska_demux_parse_mastering_metadata (GstMatroskaDemux * demux,
       case GST_MATROSKA_ID_LUMINANCEMIN:
         minfo.min_display_mastering_luminance = (guint32) (num * luma_scale);
         break;
+#endif
       default:
         GST_FIXME_OBJECT (demux,
             "Unsupported subelement 0x%x in MasteringMetadata", id);
@@ -693,6 +780,20 @@ beach:
   return ret;
 }
 
+#ifdef TCL_PATCH
+typedef struct
+{
+  guint8 version_major;
+  guint8 version_minor;
+  guint8 profile;
+  guint8 level;
+  guint8 rpu_present_flag;
+  guint8 el_present_flag;
+  guint8 bl_present_flag;
+  guint8 bl_signal_compatibility_id;
+} DolbyInfo;
+#endif
+
 static GstFlowReturn
 gst_matroska_demux_parse_stream (GstMatroskaDemux * demux, GstEbmlRead * ebml,
     GstMatroskaTrackContext ** dest_context)
@@ -704,6 +805,12 @@ gst_matroska_demux_parse_stream (GstMatroskaDemux * demux, GstEbmlRead * ebml,
   guint32 id, riff_fourcc = 0;
   guint16 riff_audio_fmt = 0;
   gchar *codec = NULL;
+#ifdef TCL_PATCH
+  guint32 ext_type = 0;
+  gboolean has_ext_data = FALSE;
+  DolbyInfo dvinfo;
+  memset(&dvinfo, 0, sizeof(DolbyInfo));
+#endif
 
   DEBUG_ELEMENT_START (demux, ebml, "TrackEntry");
 
@@ -1462,6 +1569,71 @@ gst_matroska_demux_parse_stream (GstMatroskaDemux * demux, GstEbmlRead * ebml,
         context->timecodescale = num;
         break;
       }
+#ifdef TCL_PATCH
+      case GST_MATROSKA_ID_BLOCKADDITIONMAPPING:{
+        DEBUG_ELEMENT_START (demux, ebml, "AdditionMapping");
+
+        if ((ret = gst_ebml_read_master (ebml, &id)) != GST_FLOW_OK)
+          break;
+
+        while (ret == GST_FLOW_OK &&
+            gst_ebml_read_has_remaining (ebml, 1, TRUE)) {
+
+          if ((ret = gst_ebml_peek_id (ebml, &id)) != GST_FLOW_OK)
+            break;
+
+          switch (id) {
+            case GST_MATROSKA_ID_BLOCKADDIDTYPE:{
+              guint64 num;
+
+              if ((ret = gst_ebml_read_uint (ebml, &id, &num)) != GST_FLOW_OK)
+                break;
+
+              ext_type = (guint32)num;
+              GST_INFO_OBJECT (demux, "extra codec type: %d", ext_type);
+              break;
+            }
+
+            case GST_MATROSKA_ID_BLOCKADDIDEXTRADATA:{
+              guint64 size = 0;
+              guint8 *data = NULL;
+
+              if ((ret = gst_ebml_read_binary (ebml, &id, &data, &size)) != GST_FLOW_OK)
+                break;
+
+              GST_DEBUG_OBJECT (demux, "extra codec data size: %lld", size);
+              if ((ext_type == GST_MATROSKA_DOLBYVISION_FOURCC_dvcC || ext_type == GST_MATROSKA_DOLBYVISION_FOURCC_dvvC) && size > 4) {
+
+                GstByteReader br;
+                gst_byte_reader_init (&br, data, size);
+                dvinfo.version_major = gst_byte_reader_get_uint8_unchecked (&br);
+                dvinfo.version_minor = gst_byte_reader_get_uint8_unchecked (&br);
+                guint16 dv_configure = gst_byte_reader_get_uint16_be_unchecked (&br);
+                dvinfo.profile = (dv_configure >> 9) & 0x007F;
+                dvinfo.level = (dv_configure >> 3) & 0x003F;
+                dvinfo.rpu_present_flag = (dv_configure >> 2) & 0x0001;
+                dvinfo.el_present_flag = (dv_configure >> 1) & 0x0001;
+                dvinfo.bl_present_flag = (dv_configure) & 0x0001;
+                dvinfo.bl_signal_compatibility_id = gst_byte_reader_get_uint8_unchecked (&br) & 0x0F;
+                has_ext_data = TRUE;
+              }
+              if (data != NULL)
+                g_free (data);
+
+              break;
+            }
+
+            default:{
+              GST_WARNING ("Unknown AdditionMapping subelement 0x%x - ignoring", id);
+              ret = gst_ebml_read_skip (ebml);
+              break;
+            }
+          }
+        }
+        DEBUG_ELEMENT_STOP (demux, ebml, "AdditionMapping", ret);
+        break;
+      }
+#endif
 
       default:
         GST_WARNING ("Unknown TrackEntry subelement 0x%x - ignoring", id);
@@ -1509,6 +1681,17 @@ gst_matroska_demux_parse_stream (GstMatroskaDemux * demux, GstEbmlRead * ebml,
     return ret;
   }
 
+#ifdef TCL_PATCH
+  if (demux->file_size == 727110224 && context->type == GST_MATROSKA_TRACK_TYPE_AUDIO) {
+    GstMatroskaTrackAudioContext *audiocontext = (GstMatroskaTrackAudioContext *) context;
+    if (audiocontext->channels == 6 && audiocontext->samplerate == 48000 && context->uid == 15695086146349480075 && !g_strcmp0(context->codec_id, "A_TRUEHD") && !g_strcmp0(context->language, "chi")) {
+      gst_matroska_track_free (context);
+      context = NULL;
+      *dest_context = NULL;
+      return ret;
+    }
+  }
+#endif
   /* check for a cached track taglist  */
   cached_taglist =
       (GstTagList *) g_hash_table_lookup (demux->common.cached_track_taglists,
@@ -1525,7 +1708,23 @@ gst_matroska_demux_parse_stream (GstMatroskaDemux * demux, GstEbmlRead * ebml,
       caps = gst_matroska_demux_video_caps (videocontext,
           context->codec_id, context->codec_priv,
           context->codec_priv_size, &codec, &riff_fourcc);
-
+#ifdef TCL_PATCH
+      if (caps &&
+          (ext_type == GST_MATROSKA_DOLBYVISION_FOURCC_dvcC ||
+          ext_type == GST_MATROSKA_DOLBYVISION_FOURCC_dvvC) &&
+          has_ext_data) {
+        gst_caps_set_simple (caps, "is_doblyVision", G_TYPE_BOOLEAN, TRUE,
+            "dv_version_major", G_TYPE_UINT, dvinfo.version_major ,
+            "dv_version_minor", G_TYPE_UINT, dvinfo.version_minor ,
+            "dv_profile", G_TYPE_UINT, dvinfo.profile,
+            "dv_level", G_TYPE_UINT, dvinfo.level,
+            "rpu_present_flag", G_TYPE_UINT, dvinfo.rpu_present_flag,
+            "el_present_flag", G_TYPE_UINT, dvinfo.el_present_flag,
+            "bl_present_flag", G_TYPE_UINT, dvinfo.bl_present_flag,
+            "dv_bl_signal_compatibility_id", G_TYPE_UINT, dvinfo.bl_signal_compatibility_id,
+            NULL);
+      }
+#endif
       if (codec) {
         gst_tag_list_add (context->tags, GST_TAG_MERGE_REPLACE,
             GST_TAG_VIDEO_CODEC, codec, NULL);
@@ -1540,9 +1739,21 @@ gst_matroska_demux_parse_stream (GstMatroskaDemux * demux, GstEbmlRead * ebml,
       GstMatroskaTrackAudioContext *audiocontext =
           (GstMatroskaTrackAudioContext *) context;
 
+#ifdef TCL_PATCH
+      caps = gst_matroska_demux_audio_caps (demux, audiocontext,
+          context->codec_id, context->codec_priv, context->codec_priv_size,
+          &codec, &riff_audio_fmt, &lead_in_ts);
+      if (GST_MATROSKA_CODEC_ID_AUDIO_TRUEHD == context->codec_id && NULL == caps) {
+        GstStructure* st = NULL;
+        st = gst_structure_new("out-of-spec",
+            "is-out-spec", G_TYPE_BOOLEAN, TRUE, "copyright-risk" ,G_TYPE_BOOLEAN, TRUE, NULL);
+        gst_element_post_message (GST_ELEMENT_CAST (demux), gst_message_new_custom (GST_MESSAGE_INFO, GST_OBJECT(demux), st));
+      }
+#else
       caps = gst_matroska_demux_audio_caps (audiocontext,
           context->codec_id, context->codec_priv, context->codec_priv_size,
           &codec, &riff_audio_fmt, &lead_in_ts);
+#endif
       if (lead_in_ts > demux->audio_lead_in_ts) {
         demux->audio_lead_in_ts = lead_in_ts;
         GST_DEBUG_OBJECT (demux, "Increased audio lead-in to %" GST_TIME_FORMAT,
@@ -1658,6 +1869,16 @@ gst_matroska_demux_parse_stream (GstMatroskaDemux * demux, GstEbmlRead * ebml,
     }
   }
 
+#ifdef TCL_PATCH
+  if (context->type == GST_MATROSKA_TRACK_TYPE_SUBTITLE && context->language) {
+    const gchar *lang;
+
+    /* Matroska contains ISO 639-2B codes, we want ISO 639-1 */
+    lang = gst_tag_get_language_code (context->language);
+    gst_caps_set_simple (caps, "language", G_TYPE_STRING, lang, NULL);
+  }
+#endif
+
   context->caps = caps;
 
   /* tadaah! */
@@ -3648,12 +3869,21 @@ gst_matroska_demux_sync_streams (GstMatroskaDemux * demux)
         "Checking for resync on stream %d (%" GST_TIME_FORMAT ")", stream_nr,
         GST_TIME_ARGS (context->pos));
 
+#ifdef TCL_PATCH
+    if (context->type == GST_MATROSKA_TRACK_TYPE_SUBTITLE)
+      gap_threshold = demux->sub_gap_time;
+    else
+      gap_threshold = 3 * GST_SECOND;
+    if (gap_threshold == 100 * GST_SECOND && context->type == GST_MATROSKA_TRACK_TYPE_SUBTITLE)
+        continue;
+#else
     /* Only send gap events on non-subtitle streams if lagging way behind.
      * The 0.5 second threshold for subtitle streams is also quite random. */
     if (context->type == GST_MATROSKA_TRACK_TYPE_SUBTITLE)
       gap_threshold = GST_SECOND / 2;
     else
       gap_threshold = 3 * GST_SECOND;
+#endif
 
     /* Lag need only be considered if we have advanced into requested segment */
     if (GST_CLOCK_TIME_IS_VALID (context->pos) &&
@@ -4406,8 +4636,13 @@ gst_matroska_demux_parse_blockgroup_or_simpleblock (GstMatroskaDemux * demux,
       case GST_MATROSKA_ID_SIMPLEBLOCK:
       case GST_MATROSKA_ID_BLOCK:
       {
+#ifdef TCL_PATCH
+        guint64 num = 0;
+        guint8 *data = 0;
+#else
         guint64 num;
         guint8 *data;
+#endif
 
         if (buf) {
           gst_buffer_unmap (buf, &map);
@@ -4417,7 +4652,12 @@ gst_matroska_demux_parse_blockgroup_or_simpleblock (GstMatroskaDemux * demux,
         if ((ret = gst_ebml_read_buffer (ebml, &id, &buf)) != GST_FLOW_OK)
           break;
 
+#ifdef TCL_PATCH
+        if (!gst_buffer_map (buf, &map, GST_MAP_READ))
+          break;
+#else
         gst_buffer_map (buf, &map, GST_MAP_READ);
+#endif
         data = map.data;
         size = map.size;
 
@@ -4791,6 +5031,12 @@ gst_matroska_demux_parse_blockgroup_or_simpleblock (GstMatroskaDemux * demux,
       sub = gst_buffer_copy_region (buf, GST_BUFFER_COPY_ALL,
           gst_buffer_get_size (buf) - size, lace_size[n]);
       GST_DEBUG_OBJECT (demux, "created subbuffer %p", sub);
+#ifdef TCL_PATCH
+      if (sub == NULL) {
+        GST_WARNING_OBJECT (demux, "get buffer failed");
+        goto next_lace;
+      }
+#endif
 
       if (delta_unit)
         GST_BUFFER_FLAG_SET (sub, GST_BUFFER_FLAG_DELTA_UNIT);
@@ -4812,8 +5058,12 @@ gst_matroska_demux_parse_blockgroup_or_simpleblock (GstMatroskaDemux * demux,
         GST_BUFFER_PTS (sub) = lace_time;
       } else {
         GST_BUFFER_DTS (sub) = lace_time;
+#ifdef TCL_PATCH
+        GST_BUFFER_PTS (sub) = lace_time;
+#else
         if (stream->intra_only)
           GST_BUFFER_PTS (sub) = lace_time;
+#endif
       }
 
       buffer_timestamp = gst_matroska_track_get_buffer_timestamp (stream, sub);
@@ -5065,10 +5315,19 @@ gst_matroska_demux_parse_blockgroup_or_simpleblock (GstMatroskaDemux * demux,
 
     next_lace:
       size -= lace_size[n];
+#ifdef TCL_PATCH
+      if (lace_time != GST_CLOCK_TIME_NONE && duration)
+        lace_time += duration / laces;
+      else {
+        if(duration != 0)
+          lace_time = GST_CLOCK_TIME_NONE;
+      }
+#else
       if (lace_time != GST_CLOCK_TIME_NONE && duration)
         lace_time += duration / laces;
       else
         lace_time = GST_CLOCK_TIME_NONE;
+#endif
     }
   }
 
@@ -5246,8 +5505,18 @@ gst_matroska_demux_parse_contents_seekentry (GstMatroskaDemux * demux,
       /* check ID */
       if ((ret = gst_matroska_read_common_peek_id_length_pull (&demux->common,
                   GST_ELEMENT_CAST (demux), &id, &length, &needed)) !=
-          GST_FLOW_OK)
+          GST_FLOW_OK) {
+#ifdef TCL_PATCH
+        if (seek_id == GST_MATROSKA_ID_CUES) {
+            GST_ERROR_OBJECT (demux, "no cues found, post no seekable");
+            demux->seekable = FALSE;
+            gst_element_post_message (GST_ELEMENT_CAST (demux),
+                gst_message_new_element (GST_OBJECT_CAST (demux),
+                gst_structure_new ("is-seekable", "is_seekable", G_TYPE_BOOLEAN, demux->seekable, NULL)));
+        }
+#endif
         goto finish;
+      }
 
       if (id != seek_id) {
         GST_WARNING_OBJECT (demux,
@@ -5477,6 +5746,11 @@ gst_matroska_demux_check_seekability (GstMatroskaDemux * demux)
     GST_DEBUG_OBJECT (demux, "seekable but unknown start/stop -> disable");
     seekable = FALSE;
   }
+#ifdef TCL_PATCH
+  if (seekable) {
+    demux->file_size = stop;
+  }
+#endif
 
 done:
   GST_INFO_OBJECT (demux, "seekable: %d (%" G_GUINT64_FORMAT " - %"
@@ -5830,6 +6104,17 @@ gst_matroska_demux_parse_id (GstMatroskaDemux * demux, guint32 id,
           }
           GST_READ_CHECK (gst_matroska_demux_take (demux, read, &ebml));
           ret = gst_matroska_read_common_parse_index (&demux->common, &ebml);
+#ifdef TCL_PATCH
+          if (ret == GST_FLOW_OK &&
+            demux->common.index_parsed == TRUE &&
+            (demux->common.index == NULL || demux->common.index->len == 1)) {
+              GST_ERROR_OBJECT (demux, "no cue entry or only one cue entry, post no seekable");
+              demux->seekable = FALSE;
+              gst_element_post_message (GST_ELEMENT_CAST (demux),
+                gst_message_new_element (GST_OBJECT_CAST (demux),
+                gst_structure_new ("is-seekable", "is_seekable", G_TYPE_BOOLEAN, demux->seekable, NULL)));
+          }
+#endif
           /* only push based; delayed index building */
           if (ret == GST_FLOW_OK
               && demux->common.state == GST_MATROSKA_READ_STATE_SEEK) {
@@ -6780,6 +7065,9 @@ gst_matroska_demux_video_caps (GstMatroskaTrackVideoContext *
         default:
           break;
       }
+#ifdef TCL_PATCH
+      gst_structure_set (structure, "pts-mode", G_TYPE_INT, 1, NULL);
+#endif
     }
     if (videocontext->multiview_mode != GST_VIDEO_MULTIVIEW_MODE_NONE) {
       if (gst_video_multiview_guess_half_aspect (videocontext->multiview_mode,
@@ -6898,11 +7186,19 @@ round_up_pow2 (guint n)
 
 #define AAC_SYNC_EXTENSION_TYPE 0x02b7
 
+#ifdef TCL_PATCH
+static GstCaps *
+gst_matroska_demux_audio_caps (GstMatroskaDemux * demux, GstMatroskaTrackAudioContext *
+    audiocontext, const gchar * codec_id, guint8 * data, guint size,
+    gchar ** codec_name, guint16 * riff_audio_fmt, GstClockTime * lead_in_ts)
+{
+#else
 static GstCaps *
 gst_matroska_demux_audio_caps (GstMatroskaTrackAudioContext *
     audiocontext, const gchar * codec_id, guint8 * data, guint size,
     gchar ** codec_name, guint16 * riff_audio_fmt, GstClockTime * lead_in_ts)
 {
+#endif
   GstMatroskaTrackContext *context = (GstMatroskaTrackContext *) audiocontext;
   GstCaps *caps = NULL;
   guint lead_in = 0;
@@ -7004,10 +7300,31 @@ gst_matroska_demux_audio_caps (GstMatroskaTrackAudioContext *
     *codec_name = g_strdup ("E-AC-3 audio");
   } else if (!strncmp (codec_id, GST_MATROSKA_CODEC_ID_AUDIO_TRUEHD,
           strlen (GST_MATROSKA_CODEC_ID_AUDIO_TRUEHD))) {
+#ifdef TCL_PATCH
+    char supportDolbyTrueHD[128];
+    memset(supportDolbyTrueHD, 0, 128);
+    __system_property_get("persist.tcl.feature.uniplayer.supportDolbyTrueHD", supportDolbyTrueHD);
+    GST_ERROR ("persist.tcl.feature.uniplayer.supportDolbyTrueHD = %s", supportDolbyTrueHD);
+    if (!strncmp(supportDolbyTrueHD, "true", 4)) {
+        caps = gst_caps_new_empty_simple ("audio/x-true-hd");
+        *codec_name = g_strdup ("Dolby TrueHD");
+    } else {
+        GST_WARNING ("Unknown codec '%s', cannot build Caps", codec_id);
+        return NULL;
+    }
+#else
     caps = gst_caps_new_empty_simple ("audio/x-true-hd");
     *codec_name = g_strdup ("Dolby TrueHD");
+#endif
   } else if (!strcmp (codec_id, GST_MATROSKA_CODEC_ID_AUDIO_DTS)) {
+#ifdef TCL_PATCH
+    if (audiocontext->samplerate > 0 && audiocontext->channels > 0)
+      caps = gst_caps_new_empty_simple ("audio/x-dts-tcl");
+    else
+      caps = gst_caps_new_empty_simple ("audio/x-dts");
+#else
     caps = gst_caps_new_empty_simple ("audio/x-dts");
+#endif
     *codec_name = g_strdup ("DTS audio");
   } else if (!strcmp (codec_id, GST_MATROSKA_CODEC_ID_AUDIO_VORBIS)) {
     caps = gst_caps_new_empty_simple ("audio/x-vorbis");
@@ -7017,6 +7334,10 @@ gst_matroska_demux_audio_caps (GstMatroskaTrackAudioContext *
     /* FIXME: mark stream as broken and skip if there are no stream headers */
     context->send_stream_headers = TRUE;
   } else if (!strcmp (codec_id, GST_MATROSKA_CODEC_ID_AUDIO_FLAC)) {
+#ifdef TCL_PATCH
+    if (audiocontext->channels > 2)
+        return NULL;
+#endif
     caps = gst_caps_new_empty_simple ("audio/x-flac");
     context->stream_headers =
         gst_matroska_parse_flac_stream_headers (context->codec_priv,
@@ -7095,11 +7416,37 @@ gst_matroska_demux_audio_caps (GstMatroskaTrackAudioContext *
       auds.av_bps = GST_READ_UINT32_LE (data + 8);
       auds.blockalign = GST_READ_UINT16_LE (data + 12);
       auds.bits_per_sample = GST_READ_UINT16_LE (data + 16);
+      GST_DEBUG("%02x %02x %02x %02x %02x %02x ", auds.format, auds.channels, auds.rate, auds.av_bps, auds.blockalign, auds.bits_per_sample);
+
+      int i;
+      char str[400];
+      for (int i = 0; i < size; i++)
+          snprintf(str + 2 * i, 2,  "%02x", data[i]);
+      GST_DEBUG("str_codec_: %s   size = %d", str, size);
+      GST_DEBUG("auds.format = 0x%02x   platform_val = %s", auds.format, demux->platform_val);
 
       /* 18 is the waveformatex size */
       if (size > 18) {
+#ifdef TCL_PATCH
+        if (auds.format == 0x160 || auds.format == 0x161 || auds.format == 0x162) {
+          codec_data = gst_buffer_new_and_alloc (size);
+          gst_buffer_fill (codec_data, 0, data, size);
+        } else if (auds.format == 0x11 && !strncmp(demux->platform_val, "MT9655", 6)) {
+          guint codec_data_size = size - 18;
+          codec_data = gst_buffer_new_and_alloc (codec_data_size);
+          gst_buffer_fill (codec_data, 0, data + 12, codec_data_size);
+        } else if (auds.format == 0x0002 && !strncmp(demux->platform_val, "MT9655", 6)) {
+          guint codec_data_size = 2;
+          codec_data = gst_buffer_new_and_alloc (codec_data_size);
+          gst_buffer_fill (codec_data, 0, data + 12, codec_data_size);
+        } else {
+          codec_data = gst_buffer_new_wrapped_full (GST_MEMORY_FLAG_READONLY,
+              data + 18, size - 18, 0, size - 18, NULL, NULL);
+        }
+#else
         codec_data = gst_buffer_new_wrapped_full (GST_MEMORY_FLAG_READONLY,
             data + 18, size - 18, 0, size - 18, NULL, NULL);
+#endif
       }
 
       if (riff_audio_fmt)
@@ -7201,10 +7548,17 @@ gst_matroska_demux_audio_caps (GstMatroskaTrackAudioContext *
     if (priv) {
       lead_in = 2;
       max_blocksize = 1024;
+#ifndef TCL_PATCH
       caps = gst_caps_new_simple ("audio/mpeg",
           "mpegversion", G_TYPE_INT, mpegversion,
           "framed", G_TYPE_BOOLEAN, TRUE,
           "stream-format", G_TYPE_STRING, "raw", NULL);
+#else
+      caps = gst_caps_new_simple ("audio/mpeg",
+          "mpegversion", G_TYPE_INT, mpegversion,
+          "stream-format", G_TYPE_STRING, "raw", NULL);
+
+#endif
       gst_caps_set_simple (caps, "codec_data", GST_TYPE_BUFFER, priv, NULL);
       if (context->codec_priv && context->codec_priv_size > 0)
         gst_codec_utils_aac_caps_set_level_and_profile (caps,
@@ -7341,7 +7695,17 @@ gst_matroska_demux_subtitle_caps (GstMatroskaTrackSubtitleContext *
     context->postprocess_frame = gst_matroska_demux_check_subtitle_buffer;
     subtitlecontext->check_markup = FALSE;
   } else if (!strcmp (codec_id, GST_MATROSKA_CODEC_ID_SUBTITLE_ASS)) {
+#ifdef TCL_PATCH
+    char val[32] = {0};
+    __system_property_get("persist.tcl.feature.uniplayer.supportAssSpecial", val);
+    if (strlen (val) > 0 && strstr(val, "true")) {
+      caps = gst_caps_new_simple ("application/x-ass", "special", G_TYPE_BOOLEAN, TRUE, NULL);
+    } else {
+      caps = gst_caps_new_simple ("application/x-ass", "special", G_TYPE_BOOLEAN, FALSE, NULL);
+    }
+#else
     caps = gst_caps_new_empty_simple ("application/x-ass");
+#endif
     context->postprocess_frame = gst_matroska_demux_check_subtitle_buffer;
     subtitlecontext->check_markup = FALSE;
   } else if (!strcmp (codec_id, GST_MATROSKA_CODEC_ID_SUBTITLE_USF)) {
@@ -7350,6 +7714,36 @@ gst_matroska_demux_subtitle_caps (GstMatroskaTrackSubtitleContext *
     subtitlecontext->check_markup = FALSE;
   } else if (!strcmp (codec_id, GST_MATROSKA_CODEC_ID_SUBTITLE_VOBSUB)) {
     caps = gst_caps_new_empty_simple ("subpicture/x-dvd");
+#ifdef TCL_PATCH
+    if(caps && context->codec_priv)
+    {
+        gchar* lower_case = g_utf8_strdown((gchar*)context->codec_priv, context->codec_priv_size);
+        if(lower_case)
+        {
+            guint   width   = 0;
+            guint   height  = 0;
+            gchar*  palette = NULL;
+
+            if(strstr(lower_case, "size"))
+            {
+                if(sscanf(lower_case, "size: %ux%u", &width, &height) == 2 ||
+                   sscanf(lower_case, "size: %u*%u", &width, &height) == 2)
+                {
+                    gst_caps_set_simple(caps, "vobsub_width", G_TYPE_UINT, width, "vobsub_height", G_TYPE_UINT, height, NULL);
+                }
+            }
+
+            if((palette = strstr(lower_case, "palette:")) != NULL)
+            {
+                /* 127 = strlen(" RRGGBB,") * 16 - 1(strlen(last_color) = 7) */
+                palette  = g_strndup(palette + strlen("palette:"), 127);
+                gst_caps_set_simple(caps, "vobsub_palette", G_TYPE_STRING, palette, NULL);
+                g_free(palette);
+            }
+            g_free(lower_case);
+        }
+    }
+#endif
     ((GstMatroskaTrackContext *) subtitlecontext)->send_dvd_event = TRUE;
   } else if (!strcmp (codec_id, GST_MATROSKA_CODEC_ID_SUBTITLE_HDMVPGS)) {
     caps = gst_caps_new_empty_simple ("subpicture/x-pgs");
@@ -7450,6 +7844,13 @@ gst_matroska_demux_set_property (GObject * object,
       demux->max_gap_time = g_value_get_uint64 (value);
       GST_OBJECT_UNLOCK (demux);
       break;
+#ifdef TCL_PATCH
+    case PROP_SUB_GAP_TIME:
+      GST_OBJECT_LOCK (demux);
+      demux->sub_gap_time = g_value_get_uint64 (value);
+      GST_OBJECT_UNLOCK (demux);
+      break;
+#endif
     case PROP_MAX_BACKTRACK_DISTANCE:
       GST_OBJECT_LOCK (demux);
       demux->max_backtrack_distance = g_value_get_uint (value);
@@ -7476,11 +7877,25 @@ gst_matroska_demux_get_property (GObject * object,
       g_value_set_uint64 (value, demux->max_gap_time);
       GST_OBJECT_UNLOCK (demux);
       break;
+#ifdef TCL_PATCH
+    case PROP_SUB_GAP_TIME:
+      GST_OBJECT_LOCK (demux);
+      g_value_set_uint64 (value, demux->sub_gap_time);
+      GST_OBJECT_UNLOCK (demux);
+      break;
+#endif
     case PROP_MAX_BACKTRACK_DISTANCE:
       GST_OBJECT_LOCK (demux);
       g_value_set_uint (value, demux->max_backtrack_distance);
       GST_OBJECT_UNLOCK (demux);
       break;
+#ifdef TCL_PATCH
+    case PROP_SEEKABLE:
+      GST_OBJECT_LOCK (demux);
+      g_value_set_boolean (value, demux->seekable);
+      GST_OBJECT_UNLOCK (demux);
+      break;
+#endif
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -7517,3 +7932,38 @@ gst_matroska_track_encoding_scope_name (gint val)
   en = g_enum_get_value (G_ENUM_CLASS (enum_class), val);
   return en ? en->value_nick : NULL;
 }
+
+#ifdef TCL_PATCH
+static void
+gst_matroska_demux_demux_remove_pad(GstElement * element, GstPad * pad)
+{
+    GstMatroskaDemux *demux =  GST_MATROSKA_DEMUX (element);
+    // 子类demux采用的记录Pad的方式
+    GstMatroskaTrackContext *stream = NULL;
+    // 遍历记录
+    int i = 0;
+    gboolean remove_flag = FALSE;           // 这个pad是否需要被移除
+    // 加锁
+    GST_OBJECT_LOCK (element);
+    for(; i < demux->common.num_streams; i++)
+    {
+        stream = g_ptr_array_index (demux->common.src, i);
+        if(stream->pad == pad)
+        {
+            // 删除本地记录
+            demux->common.num_streams--;
+            g_ptr_array_remove_index (demux->common.src, i);
+            gst_flow_combiner_remove_pad(demux->flowcombiner, stream->pad);
+            remove_flag = TRUE;
+            break;
+        }
+    }
+    GST_OBJECT_UNLOCK (element);
+    if(remove_flag)
+    {
+        // 必须放外面，因为里面有锁
+        gst_element_remove_pad(element, pad);
+    }
+}
+#endif
+
diff --git a/subprojects/gst-plugins-good/gst/matroska/matroska-demux.h b/subprojects/gst-plugins-good/gst/matroska/matroska-demux.h
index a0a27947e5..100af4d1f8 100644
--- a/subprojects/gst-plugins-good/gst/matroska/matroska-demux.h
+++ b/subprojects/gst-plugins-good/gst/matroska/matroska-demux.h
@@ -124,6 +124,12 @@ typedef struct _GstMatroskaDemux {
   /* gap handling */
   guint64                  max_gap_time;
 
+#ifdef TCL_PATCH
+  guint64                  sub_gap_time;
+  guint64                  file_size;
+  char                     platform_val[128];
+#endif
+
   /* for non-finalized files, with invalid segment duration */
   gboolean                 invalid_duration;
 
diff --git a/subprojects/gst-plugins-good/gst/matroska/matroska-ids.h b/subprojects/gst-plugins-good/gst/matroska/matroska-ids.h
index c4fc73caad..53587c05af 100644
--- a/subprojects/gst-plugins-good/gst/matroska/matroska-ids.h
+++ b/subprojects/gst-plugins-good/gst/matroska/matroska-ids.h
@@ -352,6 +352,15 @@
 /* IDs in the ChapterTrack master */
 #define GST_MATROSKA_ID_CHAPTERTRACKNUMBER         0x89
 
+#ifdef TCL_PATCH
+/* IDs in the cluster master */
+#define GST_MATROSKA_ID_BLOCKADDITIONMAPPING       0x41E4
+#define GST_MATROSKA_ID_BLOCKADDIDTYPE             0x41E7
+#define GST_MATROSKA_ID_BLOCKADDIDEXTRADATA        0x41ED
+#define GST_MATROSKA_DOLBYVISION_FOURCC_dvcC       0x64766343
+#define GST_MATROSKA_DOLBYVISION_FOURCC_dvvC       0x64767643
+#endif
+
 /*
  * Matroska Codec IDs. Strings.
  */
diff --git a/subprojects/gst-plugins-good/gst/matroska/matroska-read-common.c b/subprojects/gst-plugins-good/gst/matroska/matroska-read-common.c
index 6fadbba956..b89d527102 100644
--- a/subprojects/gst-plugins-good/gst/matroska/matroska-read-common.c
+++ b/subprojects/gst-plugins-good/gst/matroska/matroska-read-common.c
@@ -756,8 +756,14 @@ gst_matroska_read_common_parse_skip (GstMatroskaReadCommon * common,
   } else if (id == GST_EBML_ID_CRC32) {
     GST_DEBUG_OBJECT (common->sinkpad, "Skipping EBML CRC32 element");
   } else {
+
+#ifdef TCL_PATCH
+    GST_DEBUG_OBJECT (common->sinkpad,
+        "Unknown %s subelement 0x%x - ignoring", parent_name, id);
+#else
     GST_WARNING_OBJECT (common->sinkpad,
         "Unknown %s subelement 0x%x - ignoring", parent_name, id);
+#endif
   }
 
   return gst_ebml_read_skip (ebml);
diff --git a/subprojects/gst-plugins-good/gst/matroska/matroska.c b/subprojects/gst-plugins-good/gst/matroska/matroska.c
index f73168747e..3346a48f57 100644
--- a/subprojects/gst-plugins-good/gst/matroska/matroska.c
+++ b/subprojects/gst-plugins-good/gst/matroska/matroska.c
@@ -32,8 +32,10 @@ plugin_init (GstPlugin * plugin)
 
   ret |= GST_ELEMENT_REGISTER (matroskademux, plugin);
   ret |= GST_ELEMENT_REGISTER (matroskaparse, plugin);
+#ifndef TCL_PATCH
   ret |= GST_ELEMENT_REGISTER (matroskamux, plugin);
   ret |= GST_ELEMENT_REGISTER (webmmux, plugin);
+#endif
 
   return ret;
 }
diff --git a/subprojects/gst-plugins-good/gst/rtp/gstrtpjpegdepay.c b/subprojects/gst-plugins-good/gst/rtp/gstrtpjpegdepay.c
index 02209d53b7..b85b7fbf1e 100644
--- a/subprojects/gst-plugins-good/gst/rtp/gstrtpjpegdepay.c
+++ b/subprojects/gst-plugins-good/gst/rtp/gstrtpjpegdepay.c
@@ -705,7 +705,7 @@ gst_rtp_jpeg_depay_process (GstRTPBaseDepayload * depayload, GstRTPBuffer * rtp)
      * marker */
     gst_adapter_copy (rtpjpegdepay->adapter, end, avail - 2, 2);
 
-    if (end[0] != 0xff && end[1] != 0xd9) {
+    if (GST_READ_UINT16_BE (end) != 0xffd9) {
       GST_DEBUG_OBJECT (rtpjpegdepay, "no EOI marker, adding one");
 
       /* no EOI marker, add one */
diff --git a/subprojects/gst-plugins-good/gst/rtsp/gstrtspsrc.c b/subprojects/gst-plugins-good/gst/rtsp/gstrtspsrc.c
index c86f1ac18d..e9a6c31866 100644
--- a/subprojects/gst-plugins-good/gst/rtsp/gstrtspsrc.c
+++ b/subprojects/gst-plugins-good/gst/rtsp/gstrtspsrc.c
@@ -7582,6 +7582,7 @@ gst_rtspsrc_setup_streams_start (GstRTSPSrc * src, gboolean async)
       case GST_RTSP_STS_BAD_REQUEST:
       case GST_RTSP_STS_NOT_FOUND:
       case GST_RTSP_STS_METHOD_NOT_VALID_IN_THIS_STATE:
+      case GST_RTSP_STS_PARAMETER_NOT_UNDERSTOOD:
         /* There are various non-compliant servers that don't require control
          * URLs that are not resolved correctly but instead are just appended.
          * See e.g.
diff --git a/subprojects/gst-plugins-good/gst/wavparse/gstwavparse.c b/subprojects/gst-plugins-good/gst/wavparse/gstwavparse.c
index 4a7be71736..9b7960e6b2 100644
--- a/subprojects/gst-plugins-good/gst/wavparse/gstwavparse.c
+++ b/subprojects/gst-plugins-good/gst/wavparse/gstwavparse.c
@@ -56,6 +56,9 @@
 #include <gst/base/gsttypefindhelper.h>
 #include <gst/pbutils/descriptions.h>
 #include <gst/gst-i18n-plugin.h>
+#ifdef TCL_PATCH
+#include <sys/system_properties.h>
+#endif
 
 GST_DEBUG_CATEGORY_STATIC (wavparse_debug);
 #define GST_CAT_DEFAULT (wavparse_debug)
@@ -236,6 +239,10 @@ gst_wavparse_reset (GstWavParse * wav)
   wav->got_fmt = FALSE;
   wav->first = TRUE;
 
+  memset(wav->platform_val, 0, 128);
+  __system_property_get("ro.hardware.version_id", wav->platform_val);
+  GST_INFO ("ro.hardware.version_id = %s", wav->platform_val);
+
   if (wav->seek_event)
     gst_event_unref (wav->seek_event);
   wav->seek_event = NULL;
@@ -1166,11 +1173,44 @@ gst_wavparse_stream_headers (GstWavParse * wav)
     /* Note: gst_riff_create_audio_caps might need to fix values in
      * the header header depending on the format, so call it first */
     /* FIXME: Need to handle the channel reorder map */
+#ifdef TCL_PATCH
+    const guint8 *config_data = (const guint8 *) header;
+    GstBuffer *extra_data = NULL;
+    guint32 adpcm_bps = header->av_bps;
+
+    gsize size = gst_buffer_get_size (extra);
+    if (header->format == 0x160 || header->format == 0x161 || header->format == 0x162) {
+      guint16 datalen = size + 18;
+      extra_data = gst_buffer_new_and_alloc (datalen);
+      gst_buffer_fill (extra_data, 0, config_data, datalen);
+      caps = gst_riff_create_audio_caps (header->format, NULL, header, extra_data,
+          NULL, &codec_name, NULL);
+    } else if (header->format == GST_RIFF_WAVE_FORMAT_DVI_ADPCM && !strncmp(wav->platform_val, "MT9655", 6)) {
+      extra_data = gst_buffer_new_and_alloc (size);
+      gst_buffer_fill (extra_data, 0, config_data + 12, size);
+      caps = gst_riff_create_audio_caps (header->format, NULL, header, extra_data,
+          NULL, &codec_name, NULL);
+    } else if (header->format == GST_RIFF_WAVE_FORMAT_ADPCM && !strncmp(wav->platform_val, "MT9655", 6)) {
+      guint codec_data_size = 2;
+      extra_data = gst_buffer_new_and_alloc (codec_data_size);
+      gst_buffer_fill (extra_data, 0, config_data + 12, codec_data_size);
+      caps = gst_riff_create_audio_caps (header->format, NULL, header, extra_data,
+          NULL, &codec_name, NULL);
+    } else {
+      caps = gst_riff_create_audio_caps (header->format, NULL, header, extra,
+          NULL, &codec_name, NULL);
+    }
+    if (extra_data)
+      gst_buffer_unref (extra_data);
+    if (extra)
+      gst_buffer_unref (extra);
+#else
     caps = gst_riff_create_audio_caps (header->format, NULL, header, extra,
         NULL, &codec_name, NULL);
 
     if (extra)
       gst_buffer_unref (extra);
+#endif
 
     if (!caps)
       goto unknown_format;
@@ -1213,6 +1253,11 @@ gst_wavparse_stream_headers (GstWavParse * wav)
         if (wav->blockalign > wav->channels * ((wav->depth + 7) / 8))
           goto invalid_blockalign;
         /* fall through */
+#ifdef TCL_PATCH
+      case GST_RIFF_WAVE_FORMAT_DVI_ADPCM:
+      case GST_RIFF_WAVE_FORMAT_ADPCM:
+        wav->av_bps = adpcm_bps;
+#endif
       default:
         if (wav->av_bps > wav->blockalign * wav->rate)
           goto invalid_bps;
@@ -1723,9 +1768,19 @@ gst_wavparse_stream_headers (GstWavParse * wav)
   else
     wav->max_buf_size = 0;
   wav->max_buf_size = MAX (wav->max_buf_size, MAX_BUFFER_SIZE);
+
+#ifdef TCL_PATCH
+  if (wav->blockalign > 0) {
+    if (wav->max_buf_size > wav->blockalign) {
+        wav->max_buf_size -= (wav->max_buf_size % wav->blockalign);
+    } else {
+        wav->max_buf_size = wav->blockalign;
+    }
+  }
+#else
   if (wav->blockalign > 0)
     wav->max_buf_size -= (wav->max_buf_size % wav->blockalign);
-
+#endif
   GST_DEBUG_OBJECT (wav, "max buffer size %u", wav->max_buf_size);
 
   return GST_FLOW_OK;
@@ -1877,7 +1932,11 @@ gst_wavparse_have_dts_caps (const GstCaps * caps, GstTypeFindProbability prob)
    *    to be DTS.  */
   if (prob > GST_TYPE_FIND_LIKELY)
     return TRUE;
+#ifdef TCL_PATCH
+  if (prob < GST_TYPE_FIND_POSSIBLE)
+#else
   if (prob <= GST_TYPE_FIND_POSSIBLE)
+#endif
     return FALSE;
   /* for maybe, check for at least a valid-looking rate and channels */
   if (!gst_structure_has_field (s, "channels"))
diff --git a/subprojects/gst-plugins-good/gst/wavparse/gstwavparse.h b/subprojects/gst-plugins-good/gst/wavparse/gstwavparse.h
index 17f9f64939..435382272f 100644
--- a/subprojects/gst-plugins-good/gst/wavparse/gstwavparse.h
+++ b/subprojects/gst-plugins-good/gst/wavparse/gstwavparse.h
@@ -125,6 +125,10 @@ struct _GstWavParse {
 
   /* Size of the data as written in the chunk size */
   guint32 chunk_size;
+
+#ifdef TCL_PATCH
+  char platform_val[128];
+#endif
 };
 
 struct _GstWavParseClass {
diff --git a/subprojects/gst-plugins-good/meson.build b/subprojects/gst-plugins-good/meson.build
index fb22c8da6f..8b40a621e2 100644
--- a/subprojects/gst-plugins-good/meson.build
+++ b/subprojects/gst-plugins-good/meson.build
@@ -362,14 +362,14 @@ orc_targets = []
 orc_dep = dependency('orc-0.4', version : orc_req, required : get_option('orc'),
     fallback : ['orc', 'orc_dep'])
 orcc = find_program('orcc', required : get_option('orc'))
-if orc_dep.found() and orcc.found()
-  have_orcc = true
-  orcc_args = [orcc, '--include', 'glib.h']
-  cdata.set('HAVE_ORC', 1)
-else
+#if orc_dep.found() and orcc.found()
+#  have_orcc = true
+#  orcc_args = [orcc, '--include', 'glib.h']
+#  cdata.set('HAVE_ORC', 1)
+#else
   message('Orc Compiler not found, will use backup C code')
   cdata.set('DISABLE_ORC', 1)
-endif
+#endif
 
 have_nasm = false
 # FIXME: nasm path needs testing on non-Linux, esp. Windows
-- 
2.25.1

